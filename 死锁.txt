--- Page 1 ---
死锁
 


--- Page 2 ---
死锁的例子
• 1、哲学家吃饭问题
当n个哲学家同时饥饿时。。。。死锁！
• 2、PC问题
生产者：先执行   P(s)后执行P(empty)：在有
界缓冲全空的时候 死锁！
或者
消费者 先执行 P(s)后执行P(full)时：在有界
缓冲全满时 死锁！

--- Page 3 ---
死锁的特点
1、小概率事件：同一批进程，同一套资源集
合，并发执行多次，只有有限的几次会死锁
2、一旦发生，后果十分严重！会在系统范围
内引发多米诺骨牌效应，导致更多进程停止，
更多资源被占用而不得释放，系统效率大大
降低
想办法解决！

--- Page 4 ---
1.死锁概念
• 指多个进程因竞争资源而造成的一种
僵局，若无外力作用，这些进程都将
永远不能再向前推进。
• 即：一组进程中，每个进程都无限等
待被该组进程中另一进程所占有的资
源，因而永远无法得到的资源，这种
现象称为进程死锁，这一组进程就称
为死锁进程。


--- Page 5 ---
  产生死锁的原因
1.系统资源不足（系统能提供的资源
集合远小于并发进程主要的资源之
和）
2.进程的推进顺序不当（引发小概率
事件） 


--- Page 6 ---
解决办法
从死锁的原因找解决办法
1、资源不足：增加资源？ 
2、推进顺序非法，调整顺序？
代价大，无止境
代价小，灵活。  but，
how?

--- Page 7 ---
死锁的必要条件
– 互斥：进程竞争临界资源
– 保持并请求（部分分配）：进程已持有一部
分资源，为了顺利运行，还需要申请另一部分资源
– 不可剥夺条件：已分配给进程的资源，
在进程使用完毕主动释放之前不得强制
剥夺
– 环路条件：系统的资源分配图中出现了
环路

--- Page 8 ---
资源分配图
 1、节点：进程节点和资源节点
2、有向边：进程指向资源的请求边
           资源指向进程的分配边
以两个哲学家吃饭为例，死锁发生的时候： 
p1
{
p(s1)
p(s2)
吃饭
v(s1)
v(s2)
}
p2
{
p(s2)
p(s1)
吃饭
v(s1)
v(s2)
}


--- Page 9 ---
思路一：死锁预防
定理成立，则定力的逆否定理也成立
通过破坏死锁的四个必要条件之一，使得死
锁的必要条件永远不会成立，则死锁不会产
生
其中互斥条件一般不破坏，不仅不破坏，还
需要采用手段尽量保证。所以后面讨论其他
三个条件的破坏方法。

--- Page 10 ---
10
A、破坏“保持并请求条件”： 
• 系统要求所有进程要一次性地申请在进程整个推进过程
中所需要的全部资源。这样该进程在运行期间，将摒弃
请求条件，不会再提出资源要求，因而不会发生死锁。
（静态资源分配法）
优点：简单且安全    
缺点：
1、进程难以一次性地提出全部资源要求；
2、只要有一种资源不能满足该进程的分配要求，其它资
源也全部不分配给该进程而让进程等待，能够获得全部
资源开始运行的进程数减少，系统并发度降低；
3、某些资源可能进程仅仅最后阶段才使用，或者只使用
一个短暂时间，也必须一开始就分配给它独占，造成资
源严重浪费。资源利用率低

--- Page 11 ---
2025-12-1 11
B、破坏“不剥夺条件”：
•   采用这种方法时，不要求进程一次性地提出全部资源
要求，进程可以在只满足当前资源要求的情况下运行，
在需要新的资源时才提出请求。
• 但是一个已经保持了某些资源的进程，当它再提出新
的要求而不能立即满足时，必须释放它占有的所有资
源，待以后需要时再重新提出申请。这是一种动态的
分配方法，可以减少资源被长时间独占且闲置，因而
提高资源利用率。
缺点：进程放弃已经占用但尚未用完的资源可能要付出
很大的代价。动态分配比较复杂，同时也增加了系统
的开销。进程可能反复申请、撤销资源

--- Page 12 ---
12
C、破坏 “环路等待条件”：
• 系统 ，申请资源必须严格按资
源递增的顺序提出，这样在所形成的资源分配图中，不可
能再出现环路。（有序资源申请法）
• 优点：提高了资源利用率和系统的吞吐量。
• 缺点：
1、难以照顾所有用户的编程习惯；
2、按规定次序申请资源的方法，可能会限制用户自由的编程思路；
3、为系统中各种类型资源所分配的序号，必须相对稳定，这就限制了添
加新类型设备的方便性。 
4、资源利用率下降：资源使用顺序与资源申请顺序不一致，导致资
源不能充分利用

--- Page 13 ---
13
一个进程获取资源的规律：
动态执行，按需申请
a. 申请资源
b. 使用资源
c. 释放资源
显然思路一（死锁预防）的办法违背了进程
使用资源的规律，强加了一些限制条件（静
态分配、有序申请），导致资源利用率下降

--- Page 14 ---
思路二 死锁避免
• 死锁避免定义:在系统运行过程中，对进
程发出的每一次资源申请进行动态评估，
并根据评估结果决定是否分配资源，若
分配后系统可能发生死锁，则不予分配，
否则予以分配。


--- Page 15 ---
• 由于在避免死锁的策略中，允许进程动态
地按需申请资源。因而，系统在进行资源
分配之前预先计算资源分配的安全性。若
此次分配不会导致系统进入不安全状态，
则将资源分配给进程；否则，进程等待。
其中最具有代表性的避免死锁算法是银行
家算法。

--- Page 16 ---
3. 安全状态与不安全状态
     安 全 状 态 指 系 统 能 按 某 种 进 程 顺 序
{P1，…，Pn}来为每个进程Pi(1≤i≤n）
分配其所需资源，直至最大需求，使每
个进程都可顺序完成。若系统不存在这
样一个序列，则称系统处于不安全状态。
如果存在，则称序列<P1，…，Pn>为安
全序列。
     


--- Page 17 ---
        安全状态之例
        假定系统中有三个进程P1、 P2和P3，共有12台磁带机。
进程P1总共要求10台磁带机，P2和P3分别要求4台和9台。假
设在T0时刻，进程P1、P2和P3已分别获得5台、2台和2台磁
带机，尚有3台空闲未分配，如下表所示： 
进 程 最 大 需 求 已 分 配 可 用 
P1
P2
P3
10
4
9
5
2
2
3
问：T0时刻是否安全？
2
7
5

--- Page 18 ---
安全状态与不安全状态
  不安全状态:不存在一个安全序列，不安
全状态不一定导致死锁


--- Page 19 ---
4.利用银行家算法避免死锁 
1)银行家算法中的数据结构 
        (1) 可利用资源向量Available。这是一个含有m个元素的
数组，其中的每一个元素代表一类可利用的资源数目，其初
始值是系统中所配置的该类全部可用资源的数目，其数值随
该类资源的分配和回收而动态地改变。如果Available［j］=K，
则表示系统中现有Rj类资源K个。
avilable = [4，3，7]表示一共有三类资源，每一类的可用数量
分别是4个，3个，7个 


--- Page 20 ---
       (2) 最大需求矩阵Max。这是一个n×m的矩阵，它定义了系
统中n个进程中的每一个进程对m类资源的最大需求。如果Max［i，
j］=K，则表示进程i需要Rj类资源的最大数目为K。
           
max                            allocation                          need
 =                                           =                            = 
       (3) 分配矩阵Allocation。这也是一个n×m的矩阵，它定义了
系 统 中 每 一 类 资 源 当 前 已 分 配 给 每 一 进 程 的 资 源 数 。 如 果
Allocation［i，j］=K，则表示进程i当前已分得Rj类资源的数目为
K。
       
3 3 7
2 0 1
5 1 4
6 4 2
2 0 1
1 0 0
1 0 1
2 2 2
1 3 6
1 0 1
4 1 3
4 2 0

--- Page 21 ---
(4) 需求矩阵Need。这也是一个n×m的矩阵，用以
表示每一个进程尚需的各类资源数。如果Need［i，
j］=K，则表示进程i还需要Rj类资源K个，方能完
成其任务。  
    Need［i，j］=Max［i，j］-Allocation［i，j］

--- Page 22 ---
        2)银行家算法
       设Requesti是进程Pi的请求向量，是一个m元向量，例如
Requesti=（2，0，1），表示进程Pi需要2个R1，0个R2，1个
R3资源。当Pi发出资源请求后，系统按下述步骤进行检查：
       (1) 如果Requesti［j］≤Need［i，j］，便转向步骤2；否
则认为出错，因为它所需要的资源数已超过它所宣布的最大
值(判断资源申请的合法性，不能超过最大需求)。
       (2) 如果Requesti［j］≤Available［j］，便转向步骤(3)；
否则， 表示尚无足够资源，Pi须等待（判断操作系统进行资
源分配的能力）。 

--- Page 23 ---
       (3) 系统试探着把资源分配给进程Pi，并修改下面数据
结构中的数值：
  Available［j］∶=Available［j］-Requesti［j］;
  Allocation［i，j］∶=Allocation［i，j］+Requesti［j］;
  Need［i，j］∶=Need［i，j］-Requesti［j］;
       (4) 系统执行安全性算法，检查此次资源分配后，系统
是否处于安全状态。若安全，才正式将资源分配给进程Pi，
以完成本次分配；否则， 将本次的试探分配作废，恢复原
来的资源分配状态，让进程Pi等待。 

--- Page 24 ---
3)安全性算法 
(1) 设置两个向量：
① 工作向量Work: 它表示系统可提供给进程继续运行所需
的各类资源数目，它含有m个元素，在执行安全算法开始时，
Work∶=Available; 
② Finish: 它表示系统是否有足够的资源分配给进程，使之
运行完成。开始时先做Finish［i］∶=false; 当有足够资源分
配给进程时， 再令Finish［i］∶=true。 

--- Page 25 ---
       (2) 从进程集合中找到一个能满足下述条件的进程：         
① Finish［i］=false; ② Need［i，j］≤Work［j］； 若找到， 
执行步骤(3)， 否则，执行步骤(4)。
       (3) 当进程Pi获得资源后，可顺利执行，直至完成，并释放
出分配给它的资源，故应执行：
 Work［j］∶=Work［i］+Allocation［i，j］;
  Finish［i］∶=True;
  go to step 2; 
       (4) 如果所有进程的Finish［i］=true都满足， 则表示系
统处于安全状态；否则，系统处于不安全状态。 

--- Page 26 ---
4) 银行家算法之例 
    假定系统中有五个进程｛P0， P1， P2， P3， P4｝和三类资源｛A， B， C｝，
各种资源的数量分别为10、5、7，在T0时刻的资源分配情况如图 3-16 所示。
available = (10,5,7)  - （7,2,5） = (3,3,2)
Max(A   B   C）Allocate(A B C) Need(A B C) work finish
P0 7，5，3 0，1，0
P1 3，2 ，2 2，0，0
P2 9，0，2 3，0，2
P3 2，2，2 2，1，1
P4 4，3，3 0，0，2
7，4，3
1，2，2
6，0，0
0，1，1
4，3，1
25,12,12 7，2，5
3,3,2
F
F
F
F
F
5,3,2 T   1
7,4,3 T   2
7,5,3
10,5,5
10,5,7
T   3
T   4
T   5
P1,P3,P0,P2,p4为所求安全序列！安全！

--- Page 27 ---
  P1请求资源：P1发出请求向量Request1=(1，0，2),
(1)请求合法性(1,0,2) < (1,2,2)
(2)os能力判断（1，0,2 ）< (3,3,2)   
（3）试分配
Max(A   B   C）Allocate(A B C) Need(A B C) work finish
P0 7，5，3 0，1，0
P1 3，2 ，2 2，0，0
P2 9，0，2 3，0，2
P3 2，2，2 2，1，1
P4 4，3，3 0，0，2
7，4，3
1，2，2
6，0，0
0，1，1
4，3，1
3,3,2
F
F
F
F
F
5,3,2 T   1
7,4,5 T   3
10,5,7
10,4,7
5,3,4
T   5
T   4
T  2
3，0，2 0，2，0
2，3，0
P1,p4,p3p2,p0为所求安全序列！系统状态是安全的！
请求合法！
OS有能力满足进程请求

--- Page 28 ---
       (3) P4请求资源：P4发出请求向量Request4=(3，3，0)，
系统按银行家算法进行检查：
       ① Request4(3， 3， 0)≤Need4(4， 3， 1);
       ② Request4(3， 3， 0) <      Available(2， 3， 0)， 
os拒绝P4请求！
请求合法！
OS没有能力满足进程的本次资源申请！

--- Page 29 ---
 （4） P0请求资源：P0发出请求向量Request0=(0，2，0),
(1) Request0(0, 2, 0)≤Need0(7, 4, 3);
(2)os能力判断Request0(0, 2, 0)≤Available(2, 3, 0)   
（3）试分配
Max(A   B   C）Allocate(A B C) Need(A B C) work finish
P0 7，5，3 0，1，0
P1 3，2 ，2
P2 9，0，2 3，0，2
P3 2，2，2 2，1，1
P4 4，3，3 0，0，2
7，4，3
1，2，2
6，0，0
0，1，1
4，3，1
2，3，0
No
No
No
3，0，2 0，2，0
2，3，0
死也找不到安全序列！系统状态是不安全的！
请求合法！
OS有能力满足进程请求
0，3，0
 7，2，3
2，1，0
No
No

--- Page 30 ---
 （4）OS拒绝进程P0的请求，数据回退到试分配前的状态！ 
Max(A   B   C）Allocate(A B C) Need(A B C) work finish
P0 7，5，3 0，1，0
P1 3，2 ，2
P2 9，0，2 3，0，2
P3 2，2，2 2，1，1
P4 4，3，3 0，0，2
7，4，3
1，2，2
6，0，0
0，1，1
4，3，1
2，3，0
3，0，2 0，2，0
2，3，0
0，3，0
 7，2，3
2，1，0

--- Page 31 ---
 （5）思考： P0 请求改为 Request0(0，1，0)，系统是否能分配
资源？
合法性请求 -----OS能力检查------试分配------判断
Max(A   B   C）Allocate(A B C) Need(A B C) work finish
P0 7，5，3 0，1，0
P1 3，2 ，2
P2 9，0，2 3，0，2
P3 2，2，2 2，1，1
P4 4，3，3 0，0，2
7，4，3
1，2，2
6，0，0
0，1，1
4，3，1
2，3，0
3，0，2 0，2，0
2，3，0

--- Page 32 ---
总结：死锁避免的特点
优点：
缺点：
判断：是否存在资源利用率下降问题？

--- Page 33 ---
思路三：检测并解除
既然死锁是小概率事件，无论死锁预防还是
死锁避免都会导致资源利用率下降。
干脆破罐破摔，对进程的资源申请和操作系
统的资源分配不做任何限制。允许死锁发生。
对系统进行周期性检测，一旦检测到系统中
发生了死锁，外力解除。

--- Page 34 ---
死锁定理（死锁充分条件）
• 当系统的资源分配图是不可完全简化时，
系统中发生了死锁。
可完全简化：通过简化方法，最终能够将资
源分配图进行简化，最终所有的节点都变成
孤立的节点（即所有的边全部消去）

--- Page 35 ---
P1
P2
r1 r2
分配边
请求边
进程结点
资源结点
小圈个数为
该资源个数

--- Page 36 ---
简化方法
重复如下两个过程
1、从资源分配图中任选一个①非孤立②不阻
塞的进程，如果其请求边可以得到满足，将
请求边改为分配边。
2、如果一个进程所有的边都是分配边，则消
去其所有分配边。

--- Page 37 ---
简化例子


--- Page 38 ---
思考
对系统进行周期性检测，一旦检测到系统中
发生了死锁，外力解除。
1、周期的选择对自锁的检测和解除有影响吗？
2、可以采用哪些外力方法解除？
3、检测并解除的方法有何优缺点？

--- Page 39 ---


--- Page 40 ---
• 1、不是井里没有水，而是你挖的不够深。不是成功来得慢，而是你努力的不够多。
• 　　2、孤单一人的时间使自己变得优秀，给来的人一个惊喜，也给自己一个好的交代。
• 　　3、命运给你一个比别人低的起点是想告诉你，让你用你的一生去奋斗出一个绝地反击的故事，所以有什么理由不努力!
• 　　4、心中没有过分的贪求，自然苦就少。口里不说多余的话，自然祸就少。腹内的食物能减少，自然病就少。思绪中没有过分欲，自然忧就少。大悲是无泪的，同样大悟
无言。缘来尽量要惜，缘尽就放。人生本来就空，对人家笑笑，对自己笑笑，笑着看天下，看日出日落，花谢花开，岂不自在，哪里来的尘埃!
• 　　5、心情就像衣服，脏了就拿去洗洗，晒晒，阳光自然就会蔓延开来。阳光那么好，何必自寻烦恼，过好每一个当下，一万个美丽的未来抵不过一个温暖的现在。
• 　　6、无论你正遭遇着什么，你都要从落魄中站起来重振旗鼓，要继续保持热忱，要继续保持微笑，就像从未受伤过一样。
• 　　7、生命的美丽，永远展现在她的进取之中;就像大树的美丽，是展现在它负势向上高耸入云的蓬勃生机中;像雄鹰的美丽，是展现在它搏风击雨如苍天之魂的翱翔中;像江
河的美丽，是展现在它波涛汹涌一泻千里的奔流中。
• 　　8、有些事，不可避免地发生，阴晴圆缺皆有规律，我们只能坦然地接受;有些事，只要你愿意努力，矢志不渝地付出，就能慢慢改变它的轨迹。
• 　　9、与其埋怨世界，不如改变自己。管好自己的心，做好自己的事，比什么都强。人生无完美，曲折亦风景。别把失去看得过重，放弃是另一种拥有;不要经常艳羡他人，
人做到了，心悟到了，相信属于你的风景就在下一个拐弯处。
• 　　10、有些事想开了，你就会明白，在世上，你就是你，你痛痛你自己，你累累你自己，就算有人同情你，那又怎样，最后收拾残局的还是要靠你自己。
• 　　11、人生的某些障碍，你是逃不掉的。与其费尽周折绕过去，不如勇敢地攀登，或许这会铸就你人生的高点。
• 　　12、有些压力总是得自己扛过去，说出来就成了充满负能量的抱怨。寻求安慰也无济于事，还徒增了别人的烦恼。
• 　　13、认识到我们的所见所闻都是假象，认识到此生都是虚幻，我们才能真正认识到佛法的真相。钱多了会压死你，你承受得了吗?带，带不走，放，放不下。时时刻刻发
悲心，饶益众生为他人。
• 　　14、梦想总是跑在我的前面。努力追寻它们，为了那一瞬间的同步，这就是动人的生命奇迹。
• 　　15、懒惰不会让你一下子跌倒，但会在不知不觉中减少你的收获;勤奋也不会让你一夜成功，但会在不知不觉中积累你的成果。人生需要挑战，更需要坚持和勤奋!
• 　　16、人生在世：可以缺钱，但不能缺德;可以失言，但不能失信;可以倒下，但不能跪下;可以求名，但不能盗名;可以低落，但不能堕落;可以放松，但不能放纵;可以虚荣，
但不能虚伪;可以平凡，但不能平庸;可以浪漫，但不能浪荡;可以生气，但不能生事。
• 　　17、人生没有笔直路，当你感到迷茫、失落时，找几部这种充满正能量的电影，坐下来静静欣赏，去发现生命中真正重要的东西。
• 　　18、在人生的舞台上，当有人愿意在台下陪你度过无数个没有未来的夜时，你就更想展现精彩绝伦的自己。但愿每个被努力支撑的灵魂能吸引更多的人同行。



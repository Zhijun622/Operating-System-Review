# 死锁

3.5
11
9
2.25
D
3
2
9
6
3
13
10
5
E
4
4
17
13
3.25
17
13
3.25
平均值
11.8
3.43
8.4
2.7
进程名
到达时间
服务时间
完成时间
周转时间
带权周转时间
完成时间
周转时间
带权周转时间
时间片
RR
q=1
RR
q=4
图3-4  q=1和q=4时进程的周转时间
3.2.5 多级队列调度算法
如前所述的各种调度算法，当它们被应用于进程调度时，由于系统中仅设置了一个进程就
绪队列，换言之，低级调度算法是固定的、单一的，因此其无法满足系统中不同用户对进程调
度策略的不同要求，且在多处理机系统中，这种低级调度算法实现机制的缺点更为突出，而多
级队列（multileved queue）调度算法恰好能够在一定程度上弥补这一缺点。
多级队列调度算法将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进
程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，一个就绪队列中的进程
可以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级。
多级队列调度算法由于设置了多个就绪队列，对每个就绪队列可以实施不同的调度算法，
因此，系统针对不同用户进程的需求，很容易提供多种调度策略。例如，系统可以有两个队列
分别用于前台进程和后台进程。前台队列可以采用RR调度算法进行调度，而后台队列可以采用
FCFS调度算法进行调度，前台队列可以绝对地优先于后台队列。

--- Page 104 ---
83
第
3章 
处理机调度与死锁
在多处理机系统中，多级队列调度算法由于安排了多个就绪队列，因此可以很方便地为每
个处理机设置一个单独的就绪队列。这样，不仅对每个处理机的调度可以实施各自不同的调度
策略，而且对于一个含有多个线程的进程而言，可以根据其要求将其所有线程分配在一个就绪
队列上，并全部在一个处理机上运行；再者，对于一组需要相互合作的进程或线程而言，也可
以将它们分配到一组处理机所对应的多个就绪队列上，使它们能同时获得处理机并行执行。
3.2.6 多级反馈队列调度算法
前面介绍的各种用于进程调度的算法，都有一定的局限性。如果未指明进程长度，则短
进程优先和基于进程长度的抢占式优先调度算法都将无法使用。而多级反馈队列（multileved 
feedback queue）调度算法，则不必事先知道各种进程所需的执行时间，还可以较好地满足各种
进程的需要，因而它是目前公认的一种较好的进程调度算法。
1．多级反馈队列调度算法的调度机制
多级反馈队列调度算法的调度机制介绍如下。
（1）设置多个就绪队列。在系统中设置多个就绪队列，并为每个队列赋予不同的优先级。
第一个队列的优先级最高，第二个队列次之，其余队列的优先级依次降低。该算法为不同队列
中的进程所赋予的执行时间片的大小也各不相同，在优先级越高的队列中，其时间片越小。例
如，第二个队列的时间片要比第一个队列的时间片长 1倍，……，第i+1个队列的时间片要比第 i
个队列的时间片长1倍。图3-5所示为多级反馈队列调度算法的示意。
就绪队列1
s1
s2
至CPU
至CPU
至CPU
至CPU
s3
sn
就绪队列2
就绪队列3
就绪队列n
（时间片：s1＜s2＜s3＜…＜sn）
图3-5  多级反馈队列调度算法示意
（2）每个队列都采用FCFS调度算法 。当新进程进入内存后，首先将它放入第一个队列
的末尾，按FCFS策略等待调度。当轮到该进程执行时，如果它能在该时间片内完成，则可撤
离系统。否则（即它在该时间片结束时尚未完成），调度程序将其转入第二个队列的末尾等待
调度；如果它在第二个队列中运行一个时间片后仍未完成，则再将它放入第三个队列，依此类
推。当进程最后被降到第n队列后，在第n队列中便采取RR方式运行。
（3）按队列优先级调度。调度程序首先调度最高优先级队列中的各进程运行，仅当第一队
列空闲时，才调度第二队列中的进程运行；换言之，仅当第1～（i-1）队列均空时，才会调度第
i队列中的进程运行。如果处理机在第i队列中为某进程服务时，又有新进程进入任一优先级较高
的队列，则须立即把正在运行的进程放回到第 i队列的末尾，并把处理机分配给新到的高优先级
进程。
2．多级反馈队列调度算法的性能
在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需的处

--- Page 105 ---
84
计算机操作系统 （慕课版）
理时间，则能较好地满足各类用户的需要。①终端型用户。由于终端型用户提交的作业多属于
交互型作业，通常较小，系统只要能使这些作业在第一队列规定的时间片内完成，便可使终端
型用户感到满意。②短批处理作业用户。对于这类作业，如果可在第一队列中执行完成，则能
获得与终端型作业一样的响应时间。对于稍长的短作业，也只须在第二和第三队列各执行一个
时间片即可完成，其周转时间仍然较短。③长批处理作业用户。对于这类作业，其将依次在第  
1, 2, …, n个队列中运行，然后再按RR方式运行，用户不必担心其作业长期得不到处理。
3.2.7 基于公平原则的调度算法
前面介绍的几种调度算法所保证的只是满足要求的进程优先运行，如优先级调度算法可以
保证优先级最高的进程优先运行，但并不保证进程占用了多少处理机时间；另外也未考虑调度
的公平性。本小节将介绍两种相对公平的调度算法。
1．保证调度算法
保证调度算法是另外一种类型的调度算法，它向用户所做的并不是优先运行保证，而是明
确的性能保证，该算法可以做到调度的公平性。一种比较容易实现的性能保证措施是公平分配
处理机。如果在系统中有n个相同类型的进程同时运行，则为了公平起见，须保证每个进程都能
获得相同的处理机时间，如1/n。
在实施公平调度算法时，系统必须具有下列功能：①跟踪计算每个进程自创建以来已经执
行的处理时间；②计算每个进程应获得的处理机时间，即自创建以来的时间除以 n；③计算进
程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比；④比较各
进程获得处理机时间的比率，例如，进程A 的比率为0.5，进程B 的比率为0.8，进程C 的比率为
1.2，则通过比较发现，进程A 的比率最低；⑤调度程序应选择比率最小的进程，将处理机分配
给它，并让它一直运行，直到它的比率超过最接近它的进程的比率为止。
2．公平分享调度算法
分配给每个进程相同的处理机时间，显然，这对各进程而言体现了一定程度的公平，但如
果各用户所拥有的进程数不同，就会发生对用户的不公平问题。假如系统中仅有两个用户，用
户1启动了4个进程，用户2只启动了1个进程，采用RR调度算法让每个进程轮流运行一个时间片
的时间，这对进程而言很公平，但用户1和用户2得到的处理机时间分别为80%和20%，即对用户
2有失公平。
在公平分享调度算法中，调度的公平性主要是针对用户的，即所有用户能获得相同的处理
机时间或所要求的时间比例。然而调度又以进程为基本单位。为此，必须考虑每个用户所拥有
的进程数目。例如，系统中有两个用户，用户1 有4个进程A、B、C、D，用户2有1个进程E。为
保证两个用户能获得相同的处理机时间，则必须执行如下强制调度序列：
A E B E C E D E A E B E C E D E …
如果希望用户1所获得的处理机时间是用户2的两倍，则必须执行如下强制调度序列：
A B E C D E A B E C D E A B E C D E …
3.3 实时调度
在实时系统中，可能存在着两类不同性质的实时任务，即HRT 任务和SRT任务，它们都联

--- Page 106 ---
85
第
3章 
处理机调度与死锁
系着一个截止时间。为保证系统能正常工作，实时调度必须要满足实时任务对截止时间的要
求。为此，系统实现实时调度就应具备一定的条件。
3.3.1 实现实时调度的基本条件
1．提供必要的信息
为了实现实时调度，系统应向调度程序提供与任务相关的信息，包括： ①就绪时间 ，指
某任务的状态转换为就绪状态的起始时间，在周期任务的情况下，它是事先预知的一串时间序
列；②开始截止时间和完成截止时间 ，对于典型的实时应用，只须知道开始截止时间或者完成
截止时间；③处理时间，一个任务从开始执行直至完成所需的时间； ④资源要求，任务执行时
所需的一组资源； ⑤优先级，如果某任务的开始截止时间被错过了（势必引起故障），则应赋
予该任务“绝对”优先级；如果其开始截止时间的错过对任务的继续执行无重大影响，则可赋
予其“相对”优先级以供调度程序参考。
2．系统处理能力强
在实时系统中，若处理机的处理能力不够强，则有可能因处理机忙不过来而致使某些实时
任务不能得到及时处理，从而导致发生难以预料的后果。假定系统中有m个周期性的HRT任务，
它们的处理时间表示为Ci，周期时间表示为Pi，则在单处理机情况下，必须满足下式所示的限制
条件，系统才可调度。顺便说明一下，该限制条件并未考虑任务切换所花费的时间，因此，当
利用该限制条件时，还应适当地留有余地。
≤1。
提高系统处理能力的途径有二： ①采用单处理机系统，但须增强其处理能力，以显著减少
对每个任务的处理时间；②采用多处理机系统，假定系统中的处理机个数为N，则应将上式所示
的限制条件改为：
≤N。
3．采用抢占式调度机制
在含有HRT任务的实时系统中，广泛采用抢占式调度机制，这样便可满足HRT 任务对截止
时间的要求。但这种调度机制比较复杂。对于一些小的实时系统，如果能预知任务的开始截止
时间，则对实时任务的调度可采用非抢占式调度机制，以简化调度程序和任务调度时所花费的
系统开销。但在设计这种调度机制时，应使所有的实时任务都比较小，并在执行完关键性程序
和临界区代码后能及时地将自己阻塞起来，以便释放处理机并供调度程序去调度开始截止时间
即将到达的任务。
4．采用快速切换机制
为保证HRT任务能及时运行，在系统中还应采用快速切换机制，使之能进行任务的快速切
换。该机制应具有如下两方面的能力。 ①对中断的快速响应能力 。对紧迫的外部事件请求中断
能及时响应，要求系统具有快速硬件中断机构，此外，还应使禁止中断的时间间隔尽量短，以
免耽误时机（影响其他紧迫任务的执行）。 ②快速的任务分派能力 。为了提高分派程序的任务
切换速度，应使系统中的每个运行功能单位适当地小，以减少任务切换的时间开销。

--- Page 107 ---
86
计算机操作系统 （慕课版）
3.3.2 实时调度算法分类
可以按不同方式，对实时调度算法加以分类：①根据实时任务性质，可将实时调度算法分
为HRT调度算法和SRT调度算法；②根据调度方式，可将实时调度算法分为非抢占式调度算法和
抢占式调度算法。
1．非抢占式调度算法
（1）非抢占式轮转调度算法。由一台计算机控制若干个相同的（或类似的）对象，为每个
被控对象建立一个实时任务，并将它们排成一个轮转队列。调度程序每次选择队列中的第一个
任务投入运行。当该任务完成后，便把它挂在轮转队列的末尾进行等待，调度程序再选择下一
个队首任务运行。这种调度算法可获得数秒至数十秒的响应时间，可用于要求不太严格的实时
控制系统。
（2）非抢占式优先级调度算法 。如果在系统中还含有少数具有一定要求的实时任务，则
可采用非抢占式优先级调度算法，系统会为这些任务赋予较高的优先级。当这些实时任务到达
时，系统会把它们安排在就绪队列的队首，等待当前任务自我终止或运行完成后，再通过调度
执行队首的高优先级进程。这种调度算法在做了精心的处理后，有可能使进程的响应时间减少
到数百毫秒至数秒，因而可用于有一定要求的实时控制系统。
2．抢占式调度算法
可根据抢占发生时间的不同，将抢占式调度算法进一步分成以下两种算法。
（1）基于时钟中断的抢占式优先级调度算法。在某实时任务到达后，如果它的优先级高于
当前任务的优先级，则此时并不立即抢占当前任务的处理机，而是等到时钟中断发生后，调度
程序才会剥夺当前任务的执行，将处理机分配给新到的高优先级任务。该算法能获得较好的响
应效果，其调度时延可降低到几毫秒至几十毫秒，可用于大多数的实时系统。
（2）立即抢占的优先级调度算法 。在这种调度算法中，要求OS具有快速响应外部中断事
件的能力。一旦出现外部中断，只要当前任务未处于临界区，便能立即剥夺当前任务的执行，
把处理机分配给请求中断的紧迫任务。该算法能获得非常快的响应，其调度时延可降低到几百
微秒至几毫秒。图3-6所示为4种实时调度算法所对应的调度时间情况。
实时进程请求调度
进程1 进程2 实时进程
调度时间
（a）非抢占式轮转调度算法
进程n…
调度实时进程运行
当前进程
（c）基于时钟中断的抢占式优先级调度算法
调度时间
实时进程
实时进程请求调度 时钟中断到来时
（d）立即抢占的优先级调度算法
实时进程请求调度
当前进程 实时进程
调度时间
实时进程抢占当前
进程，并立即执行
（b）非抢占式优先级调度算法
实时进程请求调度
当前进程 实时进程
调度时间
当前进程运行完成
图3-6  4种实时调度算法所对应的调度时间情况

--- Page 108 ---
87
第
3章 
处理机调度与死锁
3.3.3 最早截止时间优先算法
最早截止时间优先（earliest deadline first， EDF）算法根据任务的截止时间确定任务的优先
级，任务的截止时间越早，其优先级越高，具有最早截止时间的任务排在队列的前面。调度程
序在选择任务时，总是选择就绪队列中的第一个任务，并为之分配处理机。EDF算法既可用于
抢占式调度方式中，也可用于非抢占式调度方式中。
1．非抢占式调度方式用于非周期实时任务
图3-7所示为将EDF算法用于非抢占式调度方式之例。该例中具有 4个非周期实时任务，它
们先后到达。系统先调度任务1执行，在任务1执行期间，任务2、任务3又先后到达。由于任务3
的开始截止时间早于任务2 的，故系统在执行完任务1 后先调度任务3 执行。在此期间任务4 又到
达了，其开始截止时间仍早于任务2的，故在任务3执行完后，系统又会先调度任务4执行，最后
才调度任务2执行。
开始截止时间
任务执行
任务到达
1
1 2 3 4
t
3 4
2
1 3 4 2
图3-7  EDF算法用于非抢占式调度方式之例
2．抢占式调度方式用于周期实时任务
图3-8所示为将EDF算法用于抢占式调度方式之例。在该例中有两个周期实时任务，任务A
和任务B的周期时间分别为20ms和 50ms，每个周期的处理时间分别为10ms和 25ms。图 3-8中的
第一行给出了两个任务的到达时间、截止时间和执行时间图，其中任务A 的到达时间为0ms、
20ms、 40ms……任务A 的最晚截止时间为20ms、 40ms、 60ms……任务B 的到达时间为0ms、
50ms、100ms……任务B的最晚截止时间为50ms、100ms……
为了说明通常的优先级调度不能适用于实时系统，该图增加了第二行和第三行。在第二
行中，假定任务A 具有较高的优先级，因此在 t=0ms时先调度A 1执行，在A 1完成后（ t=10ms）
才调度B 1执行。在 t=20ms时，又重新调度A 2执行，在 t=30ms时，A 2完成，又调度B 1执行。在
t=40ms时，又调度 A3执行，在 t=50ms时，虽然 A3已完成，但B 1已错过了它的最后期限。这
说明利用通常的优先级调度已经失败。第三行与第二行类似，只是假定任务B 具有较高的优  
先级。
第四行是采用EDF算法的时间图。在 t=0ms时，A 1和B1同时到达，由于A 1的截止时间比B 1
早，故调度A 1执行。在 t=10ms 时，A1完成，又调度B 1执行。在 t=20ms 时，A2到达，由于A 2的
截止时间比 B1早，故 B1被中断而调度 A2执行。在 t=30ms时， A2完成，又重新调度 B1执行。在
t=40ms时，A 3又到达，但B1的截止时间要比A 3早，因此仍让B1继续执行直到完成（ t=45ms），
然后再调度A3执行。在t=55ms时，A 3完成，又调度B 2执行。在该例中，利用EDF 算法可以满足
系统的要求。

--- Page 109 ---
88
计算机操作系统 （慕课版）
到达时间、执行时间和
最晚截止时间
A1
截止时间
A1
A1
0
10
20
30
40
50
60
70
80
90
100
t (ms)
t (ms)
t (ms)
t (ms)
A2
A3
A4
A5
B1
A1
A1
A1
（错过）
A4
（错过）
A2
A2
A3
B1
B1
A3
A4
A5，B2
A1
A2
B1
（错过）
A3
A4
A5，B2
A5，B2
A2
B1
B2
B2
A3
A4
A5
B1
B1
A2
A3
A5
B2
B1
B2
B2
B2
B1
B2
A2
A3
A4
A5
A2
截止时间
A3
截止时间
A4
截止时间
A5
截止时间
B1
截止时间
B2
截止时间
固定优先级调度
固定优先级调度
使用完成截止时间最早和
最晚截止时间调度
图3-8  EDF算法用于抢占式调度方式之例
3.3.4 最低松弛度优先算法
最低松弛度优先（least laxity first， LLF）算法在确定任务的优先级时，根据的是任务的
紧急程度（或松弛度）。任务紧急程度越高，赋予该任务的优先级就越高，以使其可被优先执
行。例如，一个任务在200ms时必须完成，而它本身所需的运行时长是100ms，因此调度程序必
须在100ms之前调度执行，该任务的松弛度为100ms 。再如，另一任务在400ms 时必须完成，它
本身需要运行150ms，因此其松弛度为250ms。在实现该算法时，要求系统中有一个按松弛度
排序的实时任务就绪队列，松弛度最低的任务排在最前面，调度程序会选择队列中的队首任务  
执行。
该算法主要用于抢占式调度方式中。假如在一个实时系统中有两个周期性实时任务A和B，任
务A要求每20ms执行一次，执行时长为10ms，任务B要求每50ms执行一次，执行时长为25ms。由
此可知，任务A和任务B每次必须完成的子任务A1、A2、A3…和B1、B2、B3…的时间情况如图3-9所
示。为保证不遗漏任何一次截止时间，应采用最低松弛度优先的抢占式调度机制。
A1
0 20 40 60 80 100 120 140 160
A2
B1 B2 B3
A3 A4 A5 A6 A7 A8
t (ms)
图3-9  任务A和任务B每次必须完成的子任务的时间情况
在刚开始（t1=0）时，A1必须在20ms时完成，而它本身运行又需10ms ，因此可算出A1的松
弛度为10ms。B1必须在50ms时完成，而它本身运行又需25ms，因此可算出B1的松弛度为25ms，
故调度程序应先调度A1执行。在t2=10ms时，A1执行完毕，此时，A2的松弛度可按下式算出：
A2的松弛度=必须完成时间-其本身的运行时长-当前时间
       =40ms -10ms-10ms
       =20ms。

--- Page 110 ---
89
第
3章 
处理机调度与死锁
类似地，可算出B 1的松弛度为15ms（小于A 2的松弛度），故调度程序应选择B 1运行。
在t3=30ms时，A 2的松弛度已减为0ms（即40 -10 -30），而B 1的松弛度为15ms（即50 -5-
30），于是调度程序应抢占B 1的处理机而调度A 2运行。在 t4=40ms时，A 3的松弛度为10ms
（即60 -10 -40），而B 1的松弛度仅为5ms（即50 -5-40），故又应重新调度B 1执行。在
t5=45ms时， B1执行完毕，而此时 A3的松弛度已减为 5ms（即 60-10-45），而 B2的松弛度为
30ms（即100 -25-45），于是又应调度A 3执行。在 t6=55ms时，任务A 尚未进入第4 周期，而
任务B 已进入第2 周期，故再调度B 2执行。在 t7=70ms时，A 4的松弛度已减至0ms（即80 -10-
70），而B 2的松弛度为20ms （即100 -10-70），故此时调度程序又应抢占B 2的处理机而调度
A4执行。图 3-10 所示为利用 LLF算法进行调度（具有两个周期性实时任务）的情况，图中括
注内容表示运行时长。
t (ms)
A1 （10）
B1 （20） B1 （5） B2 （15） B2 （10）
t1
0 10 20 30 40 50 60 70 80
t2 t3 t4 t5 t6 t7 t8
A2 （10） A3 （10） A4 （10）
图3-10  利用LLF算法进行调度的情况
3.3.5 优先级倒置
1．优先级倒置的形成
当前OS广泛采用优先级调度算法和抢占方式，然而在系统中存在着影响进程运行的资源，
因此可能产生“优先级倒置”（priority inversion problem）现象，即高优先级进程（或线程）被
低优先级进程（或线程）延迟或阻塞。下面通过一个例子来说明该问题。
假如有3个完全独立的进程P1、P2、P3，P1的优先级最高，P2次之，P3最低。P1和P2通过共享
的一个临界资源进行交互。相关代码如下（说明：临界资源、P 操作、V操作等的具体介绍参见
本书第4章的内容）。
P1 ：  … P （mutex） ；  CS_1 ；  V(mutex) ； …
P2 ：  … program2… ；
P3 ：  … P （mutex） ；  CS_3 ；  V(mutex) ； …
假如P3最先执行，在执行了P（mutex）操作后，进入临界区CS_3。在时刻a ，P2就绪，因为
它比P3的优先级高，所以P2抢占了P3的处理机而运行，如图3-11所示。在时刻b，P1就绪，因为它
又比P2的优先级高，所以P 1抢占了P2的处理机而运行。在时刻c ，P1执行P（mutex）操作，试图
进入临界区CS_1，但因为相应的临界资源已被P 3占用，所以P 1被阻塞。此时P 2继续运行，直到
时刻d运行结束。然后由P3接着运行，到时刻e时P3退出临界区，并唤醒P 1。因为P1比P3的优先级
高，所以P1抢占了P3的处理机而运行。
根据优先级原则，高优先级进程应当优先执行，但在此例中，P 1和P3共享着“临界资源”
而出现了不合常理的现象，高优先级进程P1因进程P3而被阻塞，又因进程P2的存在而延长了被阻
塞的时间，而且被延长的时间是不可预知和无法限定的。由此所产生的“优先级倒置”现象是
非常有害的，它不应出现在实时系统中。

--- Page 111 ---
90
计算机操作系统 （慕课版）
P1
P2
P3 a
b c
d e
抢占 抢占
抢占
P2结束
进入CS_3
P（mutex）
阻塞
P（mutex）
进入
CS_1
…
离开CS_3
V（mutex）
图3-11  优先级倒置示意
2．优先级倒置的解决方法
优先级倒置的一种简单的解决方法是规定：在进程进入临界区后，其所占用的处理机就不
允许被抢占。由图3-11可以看出，P 2即使优先级高于P3也不能执行。于是，P3就有可能会较快地
退出临界区，而不会出现上述情况。如果系统中的临界区都较短且不多，则该方法是可行的。
如果P3临界区非常长，则高优先级进程P1仍会等待很长的时间，其效果是无法令人满意的。
优先级倒置的一种比较实用的解决方法是建立在动态优先级继承的基础上的。该方法规
定：当高优先级进程P1要进入临界区去使用临界资源R 时，如果已有一个低优先级进程P 3正在使
用该资源，则此时一方面P1会被阻塞，另一方面会由P3继承P1的优先级，并一直保持到P3退出临
界区。这样做的目的在于，不让比 P3优先级稍高但比 P1优先级低的进程（如 P2）插进来，导致
延缓P3退出临界区。图3-12所示为采用了动态优先级继承方法后，P 1、P2、P3三个进程的运行情
况。由图3-12可以看出，在时刻c，P1被阻塞，但由于P3已继承了P1的优先级，它比P2优先级高，
这样就避免了P2的插入，使P1在时刻d进入临界区。该方法已在一些OS中得到了应用，且在实时
系统中是一定会用到的。
…
P1
P1结束
继承
P2
P3
进入CS_3
P（mutex） 离开CS_3
V（mutex）
a
b e
c d
阻塞
P（mutex）
进入
CS_1
图3-12  采用动态优先级继承方法后进程的运行情况
3.4 实例：Linux进程调度
Linux进程调度经历了一个发展过程。Linux内核在2.5版本之前，采用传统的UNIX调度算
法。然而，由于 2.5版本之前的 Linux 内核不支持 SMP系统，因此传统的UNIX调度算法没有考
虑SMP系统。此外，当有大量可运行进程时，系统性能表现欠佳。在Linux内核2.5版本中，调
度程序进行了大幅度改动，采用了称为 O(1)的调度算法，它的运行时间为常量，与系统内任
务数量无关。 O(1)调度算法也增加了对SMP系统的支持。然而在实践中，虽然 O(1)调度算法在
SMP系统中具有出色的性能，但是其在许多桌面计算机系统中的交互进程响应时间欠佳。在

--- Page 112 ---
91
第
3章 
处理机调度与死锁
Linux内核2.6版本的开发中，调度算法再次修改；在Linux内核v2.6.23版本的发布中，完全公平
（completely fair scheduler，CFS）调度算法成为默认的Linux进程调度算法。
Linux系统的调度基于总体调度结构，称之为调度器类（scheduler class）。它允许不同的
可动态添加的调度算法并存，每个类都有一个特定的优先级。总调度器根据调度器类的优先顺
序，依次对调度器类中的进程进行调度。挑选完调度器类后，再在选中的调度器类内，使用所
选的调度器类的算法（调度策略）进行内部的调度。调度器类的默认优先级顺序为Stop_Task ＞
Real_Time＞Fair＞Idle_Task，开发者可以根据自己的设计需求，把所属的Task配置到不同的调
度器类中。在众多的调度器类中，Fair和 Real_Time是最常用的，它们分别是采用了CFS调度算
法的默认调度类和实时调度类。
1．普通进程调度
对于一个普通进程，采用了 CFS调度算法的调度器在调度执行 SCHED_NORMAL 调度策略
时，须考虑如何分配优先级，如何挑选一个进程并使其运行，以及使其运行多久等问题。
CFS调度算法并不会采用严格的规则来为一个任务分配某个长度的时间片，而是会为每个
任务分配一定比例的CPU处理时间。每个任务分配的具体比例是根据友好值（nice value）来计
算的。友好值的范围为 -20到+19，数值较低的友好值表示相对优先级较高。具有较低友好值的
任务与具有较高友好值的任务相比，会得到更高比例的处理机时间。默认友好值为0。
需要说明的是，友好一词来自于以下想法：当一个任务增加了自身的友好值（如从0 增 
至+10）后，其优先级会降低，进而对其他任务会更加友好。
CFS调度算法没有使用离散的时间片，而是采用了目标延迟（target latency），这是每个可
运行任务应当运行一次的时间间隔。CFS调度算法会根据目标延迟按比例分配处理机时间。除
了默认值和最小值外，随着系统内的活动任务数量超过一定的阈值，目标延迟可以增加。
CFS调度算法没有直接分配优先级，相反，它通过每个任务的变量vruntime 来维护虚拟运行
时间（virtual run time），进而记录每个任务运行了多久。虚拟运行时间与基于任务优先级的衰
减因子有关：更低优先级的任务比更高优先级的任务具有更高的衰减速率。对于正常优先级的
任务（友好值为0 ），虚拟运行时间与实际物理运行时间相同。因此，如果一个默认优先级的
任务运行100ms，则它的vruntime也为100ms。如果一个较低优先级的任务运行100ms，则它的
vruntime将大于100ms。如果一个较高优先级的任务运行100ms，则它的vruntime将小于100ms。
当决定下一步运行哪个任务后，CFS调度算法就只须选择具有最小vruntime值的任务了。此外，
一个更高优先级的任务如果成为可运行任务，其就会抢占低优先级任务。进程运行的时间是根
据进程的权重进行分配的。
2．实时进程调度
Linux系统也实现了实时调度。采用SCHED_FIFO或 SCHED_RR实时策略来调度的任何任
务，与普通（非实时的、采用SCHED_NORMAL调度的）任务相比，均具有更高的优先级。
SCHED_FIFO ：这种策略对应的进程若处于可执行的状态，就会一直执行，直到它自己
被阻塞或者主动放弃CPU；它不基于时间片，可以一直执行下去，只有更高优先级的SCHED_
FIFO或者SCHED_RR才能抢占它的任务；如果存在两个同样优先级的SCHED_FIFO任务，则它
们会轮流执行，其他低优先级的任务只有等它们变为不可执行状态后才有机会执行。
SCHED_RR ：与SCHED_FIFO大致相同，只是SCHED_RR级的进程在耗尽其时间片后，
不能再执行，而是需要接受CPU的调度。当SCHED_RR耗尽时间片后，同一优先级的其他实时

--- Page 113 ---
92
计算机操作系统 （慕课版）
进程将被轮流调度。
上述两种实时策略都采用了静态优先级。Linux内核不会为给定优先级的实时进程计算动
态优先级，以保证给定优先级的实时进程总能抢占到优先级比它低的进程。实时任务分配的
静态优先级为0 ～99，而正常任务分配的静态优先级为100 ～139。这两个值域合并后形成了一
个全局的优先级方案，其中较低数值代表较高优先级。针对正常任务，系统会根据它们的友
好值来为它们分配一个优先级。这里，友好值 -20对应优先级100，而友好值+19对应优先级
139。
3.5 死锁概述
在第2章中，已经谈及死锁。例如，系统中只有一台扫描仪R 1和一台刻录
机R2。有两个进程P 1和P2，它们都准备将扫描好的文档刻录到光盘（compact 
disk，CD）上，进程P1先请求扫描仪R1并获得成功，进程P2先请求刻录机R2也
获得成功。后来P 1又请求刻录机R 2，但因它已被分配给了P 2而阻塞。P 2又请求扫描仪R 1，也因
它已被分配给了P 1而阻塞，此时两个进程都被阻塞，双方都希望对方能释放出自己所需要的资
源，但它们都会因为不能获得自己所需的资源去继续运行而无法释放自己当下占有的资源，并
且一直处于这样的僵持状态而形成 死锁。本章将对死锁发生的原因、如何预防和避免死锁等问
题做较详细的介绍。
3.5.1 资源问题
在系统中有许多不同类型的资源，其中可以引起死锁的主要是需要采用互斥访问方法的、
不可被抢占的资源。系统中此类资源有很多，如打印机、数据文件、队列、信号量等。
1．可重用资源和可消耗资源
（1）可重用资源。
可重用资源是一种可供用户重复使用多次的资源，它具有如下性质。①每个可重用资源
中的单元，只能分配给一个进程使用，而不允许多个进程共享。②进程若要使用可重用资源，
则要按照下列步骤：首先，请求资源，如果请求资源失败，则进程将会被阻塞或循环等待；然
后，使用资源，进程对资源进行操作，如用打印机进行打印；最后，释放资源，当进程使用完
资源后自己将其释放。③系统中每类可重用资源中的单元数目是相对固定的，进程在运行期间
既不能创建资源，也不能删除资源。
对资源的请求和释放通常都是利用系统调用来实现的。例如，对于设备可用request/release；
对于文件可用open/close；对于需要互斥访问的资源，进程可用信号量的wait/signal操作来对其进
行访问。每次在进程提出资源请求后，系统执行时都需要做一系列的工作。计算机系统中大多
数资源属于可重用资源。
（2）可消耗资源。
可消耗资源又称为临时性资源，它是在进程运行期间由进程动态创建和消耗的。它具有如
下性质：①每类可消耗性资源的单元数目在进程运行期间是可以不断变化的，有时它可能有许
多，有时可能为0；②进程在运行过程中，可以不断地创造可消耗资源的单元，将它们放入该资
源类的缓冲区中，以增加该资源类的单元数目；③进程在运行过程中可以请求若干个可消耗资
源单元，用于进程自己消耗，并不再将它们返回给该资源类。可消耗资源通常是由生产者进程
死锁概述


--- Page 114 ---
93
第
3章 
处理机调度与死锁
创建、由消费者进程消耗的，最典型的可消耗资源就是用于进程间通信的消息等。
2．可抢占资源和不可抢占资源
可把系统中的资源分成两类，一类是可抢占资源，另一类是不可抢占资源。
（1）可抢占资源。
可抢占资源是指，某进程在获得这类资源后，这类资源可以再被其他进程或系统抢占。例
如，优先级高的进程可以抢占优先级低的进程的处理机。再如，可把一个进程从一个存储区转
移到另一个存储区，在内存紧张时，还可以将一个进程从内存调出到外存，即抢占该进程在内
存的空间。由此可见，处理机和内存均属于可抢占资源。这类资源是不会引起死锁的。
（2）不可抢占资源。
不可抢占资源是指，一旦系统把这类资源分配给某进程后，就不能将它强行收回，而只能
在进程用完后等待其自行释放。例如，当一个进程已开始刻录光盘时，如果突然将刻录机分配
给另一个进程，则结果必然会损坏正在刻录的光盘，因此只能等刻录好光盘后，由进程自己释
放刻录机。另外，磁带机、打印机等也都属于不可抢占资源。
3.5.2 计算机系统中的死锁
死锁的起因，通常源于多个进程对资源的争夺，不仅对不可抢占资源进行争夺时会引起死
锁，而且对可消耗资源进行争夺时也会引起死锁。
1．竞争不可抢占资源引起死锁
通常，系统中所拥有的不可抢占资源的数量不足以满足多个进程运行的需要，这使得进程
在运行过程中，会因争夺资源而陷入僵局。例如，系统中有两个进程P 1和P2，他们都准备写两
个文件F1和F2，而这两个文件都属于可重用和不可抢占资源。进程P 1先打开文件F1，后打开文件
F2；进程P2先打开文件F2，后打开文件F1，下面给出了对应的代码。
     P 1    P 2
     … …      … …
     open (F1,w);   open (F2,w);
     open (F2, w);   open (F1,w);
两个进程P1和P2在并发执行时，如果P1先打开F1和F2，然后P2才去打开F1（或F2），则由于文
件F1（或F2）已被P1打开，故P2会被阻塞。当P1写完文件F1（或F2）并将其关闭时，P2会由阻塞状态
转为就绪状态，并被调度执行后实现打开文件F1（或F2）。在这种情况下，P1和P2都能正常运行下
去。若P2先打开F1和F2，然后P1才去打开F1（或F2），则P1和P2同样也可以正常运行下去。
但如果在P 1打开F1的同时，P 2去打开F 2，每个进程都占有一个打开的文件，此时就可能会
出现问题。因为当P1试图去打开F2，而P2试图去打开F1时，这两个进程都会因文件已被打开而阻
塞，它们都希望对方关闭自己所需要的文件，但谁都无法进行该操作，因此这两个进程将会无
限期地等待下去，进而形成死锁。
我们可利用资源分配图对上述问题进行描述，用方块代表可重用的资源（文件），用
圆圈代表进程，如图3-13所示。当箭头从进程指向文件时，表示进程请求资源（即请求打开
文件）；当箭头从资源指向进程时，表示该资源已被分配给了该进程（即文件已被该进程打
开）。从图3-13中可以看出，这时在P 1、P2及R1、R2之间，已经形成了一个环路，说明已进入死
锁状态。

--- Page 115 ---
94
计算机操作系统 （慕课版）
2．竞争可消耗资源引起死锁
现介绍竞争可消耗资源引起死锁。图3-14所示为3 个进程在利用消息通信机制进行通信
时，所形成的死锁情况。图中m 1、m2和m3是可消耗资源。进程P 1，一方面产生消息m 1，利
用send（ P2, m 1）原语将它发送给P 2；另一方面，它又要求从P 3接收消息m 3。而进程P 2，一
方面产生消息m 2，并利用send（ P3, m 2）原语将它发送给P 3；另一方面，它又需要接收进
程P1所产生的消息m 1。类似，进程P 3也产生消息m 3，利用send（ P1, m 3）原语将它发送给
P1，而它又要求从进程P 2接收P 2所产生的消息m 2。如果这3 个进程间的消息通信按下列步骤
进行：
P1 ：  …send （P2, m1） ；  receive （P3, m3） ； …
P2 ：  …send （P3, m2） ；  receive （P1, m1） ； …
P3 ：  …send （P1, m3） ；  receive （P2, m2） ； …
那么， 这3 个进程都可以先将消息发送给下一个进程， 也都能够接收到从上一个进程发来的消息。
因 此 ，这3 个进程可以顺利地运行下去， 而不会发生死锁。 但若改成3 个进程都先执行 receive 操
作， 后执行send 操作， 即按下列步骤进行 ：
P1 ：  …receive （P3, m3） ；  send （P2, m1） ； …
P2 ：  …receive （P1, m1） ；  send （P3, m2） ； …
P3 ：  …receive （P2, m2） ；  send （P1, m3） ； …
那 么 ，这3 个进程就会永远阻塞在它们的 receive 操作上， 等待一条永远不会发出的消息， 于是发
生死锁。
P1
P2
F1
F2
                                
P1
P3
P2
m3
m1
m2
                            图3-13  共享文件时的死锁                                                 图3-14  进程之间通信时的死锁
3．进程推进顺序不当引起死锁
除了系统中多个进程对资源的争夺会引起死锁外，进程在运行过程中，对资源进行申请和
释放的顺序是否合法，也是在系统中是否会产生死锁的一个重要因素。例如，系统中只有一台
打印机R1和一台磁带机R2可供进程P1和P2共享，由于进程在运行时具有异步特征，这就可能使得
进程P1和P2会按下述两种顺序向前推进。
（1）进程推进顺序合法。
在进程P 1和P2并发执行时，如果按图3-15中折线①所示的顺序推进，即P 1：Request  
（R1）→P1：Request（R2）→P1：Releast（R1）→P1：Release（R2）→P2：Request（R2）→P2：
Request（R1）→P2：Release（R2）→P2：Release（R1），则两个进程可顺利完成。类似地，若
按图3-15中折线②和折线③所示的顺序推进，则两个进程也可以顺利完成。我们称这种不会引
起进程死锁的推进顺序是合法的。

--- Page 116 ---
95
第
3章 
处理机调度与死锁
tP2
tP1
①
③
④
②
D
P2 Release（R1）
P1 Release（R1）
P1 Release（R2）
P2 Release（R2）
P2 Request（R1）
P2 Request（R2）
P1 Request（R1）
P1 Request（R2）
O
图3-15  进程推进顺序对死锁的影响
（2）进程推进顺序非法。
若并发进程P1和P2按图3-15中折线④所示的顺序推进，则它们将进入不安全区D 。此时P1占
有了资源R1，P2占有了资源R 2，系统处于不安全状态。如果两个进程继续向前推进，就可能发
生死锁。例如，当P 1运行到P1：Request（ R2）时，将因R 2已被P2占用而阻塞；当P 2运行到P2：
Request（ R1）时，也将因R1已被P1占用而阻塞，于是发生了进程死锁，这样的进程推进顺序就
是非法的。
3.5.3 死锁的定义、必要条件与处理方法
1．死锁的定义
在一组进程发生死锁的情况下，这组死锁进程中的每个进程都在等待另一个死锁进程
所占有的资源，或者说每个进程所等待的事件是该组中其他进程释放所占有的资源。但由于
所有这些进程都已无法运行，因此它们谁都不会释放资源，这致使没有任何一个进程可被唤
醒。这样，这组进程只能无限期地等待下去。由此可以给死锁（ deadlock ）做出如下 定义：如
果一组进程中的每个进程都在等待仅由该组进程中的其他进程才能引发的事件发生，那么该
组进程是死锁的。
2．产生死锁的必要条件
虽然进程在运行过程中可能会发生死锁，但产生死锁是需要具备一定条件的。综上所述不
难看出，产生死锁必须同时具备下列4个必要条件，只要其中任意一个条件不成立，死锁就不会
发生。
（1）互斥条件。进程对所分配到的资源进行排他性使用，即在一段时间内，某资源只能被
一个进程占用。如果此时还有其他进程请求该资源，则请求进程只能等待，直至占有该资源的
进程用毕释放。
（2）请求和保持条件。进程已经占有了至少一个资源，但又提出了新的资源请求，而该被
请求的资源已被其他进程占有，此时请求进程被阻塞，同时其对自己已占有的资源保持不放。
（3）不可抢占条件。进程已获得的资源在未使用完之前不能被抢占，只能在进程使用完时
由其自己释放。
（4）循环等待条件 。该条件指在发生死锁时，必然存在一个“进程—资源”循环链，
即进程集合{P 0, P 1, P 2, …, P n}中的P0正在等待已被P 1占用的资源，P 1正在等待已被P 2占用的资
源，……，Pn正在等待已被P0占用的资源。

--- Page 117 ---
96
计算机操作系统 （慕课版）
3．死锁的处理方法 
从原理上说，处理死锁有3种主要策略：
 采用某个协议来预防或避免死锁，确保系统永远不会进入死锁状态；
 允许系统进入死锁状态，但是会检测它，然后恢复；
 完全忽略这个问题，并假设系统永远不会出现死锁。
第一种策略包括了预防死锁方法和避免死锁方法；第二种策略包括了检测死锁方法和解除
死锁方法；第三种策略则为大多数系统（如Linux和 Windows等）所采用。下面具体介绍上述策
略实现的4种方法。
（1）预防死锁 。这是一种较简单和直观的事先预防方法。该方法是通过设置某些限制条
件，去破坏产生死锁的4个必要条件中的一个或几个来预防死锁的。预防死锁是一种较易实现的
方法，已被广泛使用。
（2）避免死锁。该方法同样属于事先预防方法，但它并不需要通过事先采取各种限制措施
来破坏产生死锁的4个必要条件，而是在资源的动态分配过程中，用某种方法防止系统进入不安
全状态，从而避免发生死锁。
（3）检测死锁 。这种方法无须事先采取任何限制性措施，允许进程在运行过程中发生死
锁。但可通过检测机构及时地检测出死锁的发生，然后采取适当措施把进程从死锁中解脱出来。
（4）解除死锁。该方法是指，当检测到系统中已发生死锁时就采取相应措施，将进程从死
锁状态中解脱出来。通常采用的措施是撤销一些进程，回收它们的资源，将回收的资源分配给
已处于阻塞状态的进程，使这些进程能够继续运行。
上述4种方法，从（1）到（4）对死锁的防范程度逐渐减弱，但对应的资源利用率却逐渐提 
高，且进程因资源因素而阻塞的频度逐渐下降（即进程并发程度逐渐提高）。
3.5.4 资源分配图
可利用资源分配图（resource allocation graph）来描述系统死锁。资源分配图是一个有向图，
它是由一组节点N和一组边E所组成的一个对偶G =（N, E），它具有下述形式的定义和限制。
（1）把 N分为两个互斥的子集，即一组进程节点 P ={P 1, P 2, …, P n}和一组资源节点  
R ={R 1, R 2, …, R n}，N = P∪R。在图3-16所示的例子中， P={P 1, P 2}，R={R 1, R 2}，N={R 1, 
R2}∪{P1, P2}。
（2）凡属于E中的一个边e∈E，其都连接着P中的一个
节点和R中的一个节点。 e ={P i, Rj}是资源请求边P i→Rj，由
进程P i指向资源R j，它表示进程P i请求一个单位的R j资源。 
e ={Rj, Pi}是资源分配边Rj→Pi，由资源Rj指向进程Pi，它表示
把一个单位的资源R j分配给进程Pi。图3-16中给出了2 个请求
边和4个分配边，即E ={（P1, R2）,（R2, P2）,（P2, R1）,（R1, 
P1）}。
用圆圈代表一个进程，用方框代表一类资源。由于一类
资源可以包含多个资源实例，我们用方框中的一个圆点来代
表一类资源中的一个资源实例。此时，请求边由进程指向方框中的R j，而分配边则始于方框中
的一个圆点。在图3-16所示的资源分配图中，P1进程已经分得了两个R1资源，并又请求了一个R2
资源；P2进程已经分得了一个R1资源和一个R2资源，并又请求了一个R1资源。
P1
P2
R2R1
图3-16  资源分配图

--- Page 118 ---
97
第
3章 
处理机调度与死锁
3.6 死锁预防
预防死锁是通过破坏产生死锁的4 个必要条件中的一个或几个来实现的（使用“假脱机技  
术”亦可预防死锁）。由于互斥条件是非共享设备所必须具备的条件，不仅不能改变，还应加
以保证。因此，预防死锁时主要是破坏产生死锁的后3个条件。
3.6.1 破坏“请求和保持”条件
为了能够破坏“请求和保持”条件，系统必须保证做到：当一个进程在请求资源时，它不
能持有不可抢占资源。该保证可通过以下两个不同的协议实现。
1．第一种协议
该协议规定，所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的
全部资源。此时，若系统有足够的可分配资源，则可把其需要的所有资源分配给它。这样，
该进程在整个运行期间便不会再提出资源要求，从而破坏了“请求”条件。系统在分配资源
时，只要有一种资源不能满足进程的要求，则即使所需的其他资源都空闲也不分配给该进
程，而是让其等待。由于该进程在等待期间未占有任何资源，从而破坏了“保持”条件，可
以预防发生死锁。
第一种协议的优点是简单、易行、安全。但缺点也极其明显。①资源被严重浪费，严重地
降低了资源利用率。进程在开始运行时，就会一次性地占用整个运行过程所需的全部资源，其
中有些资源可能仅在运行初期或运行快结束时才会使用，甚至根本不使用，可见，资源可能会
被严重浪费。②进程经常会发生饥饿现象。因为仅当进程在获得其所需的全部资源后才能开始
运行，所以可能由于个别资源长期被其他进程占用，等待该资源的进程迟迟不能开始运行，例
如，个别资源（如打印机）有可能仅在进程运行到最后时才需要。
2．第二种协议
该协议是对第一种协议的改进，它允许一个进程只获得运行初期所需的资源后，便开始运
行。进程运行过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需
资源。下面通过一个具体例子来说明第二种协议比第一种协议要好。
例如有一个进程，它所要完成的任务是，先将数据从磁带上复制到磁盘文件上，然后对磁
盘文件进行排序，最后把结果打印出来。①在采用第一种协议时，进程必须在开始时就请求磁
带机、磁盘文件和打印机，然而打印机仅在最后才会用到，所以刚开始就请求占用打印机，既
影响其利用率，还会影响其他进程的运行。此外，若刚开始时磁带机和磁盘文件空闲，但因打
印机被很多进程所需而分配给了其他进程，则该进程还需要等待。②在采用第二种协议时，进
程在开始时只须请求磁带机、磁盘文件，然后即可运行。等到磁带上的全部数据已复制到磁盘
文件中并已排序好后，便可将磁带机和磁盘文件释放掉，再去请求打印机。这不仅能使进程更
快地完成任务，提高设备的利用率，还可减少进程发生饥饿现象的概率。
3.6.2 破坏“不可抢占”条件
为了能破坏“不可抢占”条件，协议中规定，当一个已经保持了某些不可抢占资源的进程提出
新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这

--- Page 119 ---
98
计算机操作系统 （慕课版）
意味着进程已占有的资源会被暂时释放，或者说是被抢占了，从而破坏了“不可抢占”条件。
该方法实现起来比较复杂，且需要付出很大的代价。因为一个不可抢占的资源（如打印
机、刻录机等）在使用一段时间后被抢占，可能会造成进程前一阶段工作的失效，即使是采取
了某些防范措施，也会使进程前后两次运行的信息不连续。这种策略还可能会因为反复地申请
和释放资源，致使进程的执行被无限期地推迟，这不仅延长了进程的周转时间，而且也增加了
系统开销，降低了系统吞吐量。
3.6.3 破坏“循环等待”条件
一个能保证“循环等待”条件不成立的方法是，对系统的所有资源类型进行线性排序，并
赋予它们不同的序号。设 R=（R1, R2, R3,…, Rm）为资源类型的集合，为系统中的每个资源类型
赋予唯一的序号。如果系统中有磁带机、硬盘驱动器、打印机，则函数F()可进行如下定义：
F(tape drive) = 1 ；
F(disk drive) = 5 ；
F(printer) = 12 ；
在对系统所有资源类型进行线性排序后，便可采用以下预防协议：规定每个进程必须按
序号递增的顺序请求资源。一个进程在开始时可以请求某类资源R i的单元，以后，当且仅当  
F（Rj）＞F（Ri）时，进程才可以请求资源 Rj的单元。如果需要多个同类资源单元，则必须一
起请求。例如，当某进程需要同时使用打印机和磁带机时，由于磁带机序号低，而打印机序号
高，故必须先请求磁带机，再请求打印机。假如某进程已请求到一些序号较高的资源，后来又
想请求一个序号较低的资源，此时，它必须先释放所有具有相同和更高序号的资源，然后才能
申请序号低的资源。在采用这种策略后所形成的资源分配图中，不可能再出现环路，因而破坏
了“循环等待”条件。事实上，总有一个进程会占据较高序号的资源，此后它继续申请的资源
必然是空闲的，因而进程可以一直向前推进。
在采用这种策略时，应如何来规定每种资源的序号是十分重要的。通常应根据大多数进程
需要资源的先后顺序来确定资源的序号。一般情况下，进程总会首先输入程序和数据，然后进
行运算，最后将运算结果输出。因此，可以为输入设备规定较低的序号，如把磁带机定为1 ；可
以为输出设备规定较高的序号，如把打印机定为12。
这种预防死锁策略和前两种策略相比，其资源利用率和系统吞吐量都有比较明显的改善。
但也存在下列问题。
第一，为系统中各类资源规定的序号必须相对稳定，这限制了新类型设备的增加。
第二，尽管在为资源的类型分配序号时已经考虑到了大多数作业在实际使用这些资源时的
顺序，但也经常会发生这种情况：作业使用各类资源的顺序与系统规定的顺序不同，造成对资
源的浪费。
第三，为了方便用户，系统对用户在编程时所施加的限制条件应尽量少，然而这种按规定
次序申请资源的方法必然会限制用户进行简单、自主的编程。
3.7 死锁避免
避免死锁同样属于事先预防策略，但并不需要通过事先采取某种限制措
施来破坏产生死锁的必要条件，而是在资源动态分配过程中，防止系统进入不
安全状态，以避免发生死锁的。这种方法所施加的限制条件较弱，可能会获得 避免死锁


--- Page 120 ---
99
第
3章 
处理机调度与死锁
较好的系统性能。目前常用此方法来避免发生死锁。
3.7.1 系统安全状态
在避免死锁方法中，把系统的状态分为安全状态和不安全状态两种。当系统处于安全状态
时可避免发生死锁，而当系统处于不安全状态时，则可能会进入死锁状态。
1．安全状态
在避免死锁方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此
次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则可将资源分配给进程，否
则，令进程等待。所谓安全状态，是系统能按某种进程推进顺序（P 1, P2, …, Pn），为每个进程
Pi分配其所需的资源，直至满足每个进程对资源的最大需求，进而使每个进程都可顺利完成的一
种系统状态。此时，称进程推进顺序（P 1, P2, …, Pn）为安全序列。如果系统无法找到这样一个
安全序列，则称系统处于不安全状态。虽然并非所有不安全状态都必然会转为死锁状态，但当
系统进入不安全状态后，就有可能进入死锁状态。而只要系统处于安全状态，其就不会进入死
锁状态。因此，避免死锁的实质在于，使系统在进行资源分配时不进入不安全状态。
2．安全状态举例
假定系统中有3 个进程P1、P2、P3，共有12台磁带机。进程P 1总共要用10台磁带机，进程P 2
和P3分别要用4台和9台。假设在t0时刻，进程P1、P2、P3已分别获得5台、2台、2台磁带机，尚有
3台磁带机空闲（未分配），如表3-1所示。
表3 -1 进程资源分配情况表
进程 最大需求 已分配 可用
P1 10 5
3P2 4 2
P3 9 2
经分析发现，在t0时刻系统是安全的，因为这时存在一个安全序列（P 2, P1, P3），即只要系
统按此序列分配资源，就能使每个进程都顺利完成。例如在剩余的磁带机中取2 台分配给P2，使
之继续运行；待P 2完成，其可释放4 台磁带机，于是可用磁带机增至5 台；以后再将这些磁带机
全部分配给P1，使之运行；待P1完成后，其将释放出10台磁带机，P3便能获得足够的资源，从而
即可使P1、P2、P3每个进程都能顺利完成。
3．由安全状态进入不安全状态
如果不按照安全序列分配资源，则系统可能会由安全状态进入不安全状态。例如在t0时刻以
后，P3又请求了1台磁带机，若此时系统把剩余3 台中的1台分配给P3，则系统便会进入不安全状
态，因为此时已无法再找到一个安全序列。例如，把其余的2 台分配给P2，这样在P2完成后，其
只能释放4台，既不能满足P1尚需5台的要求，也不能满足P 3尚需6台的要求，致使它们都无法推
进到完成，彼此都在等待对方释放资源，进而导致死锁。类似地，如果将剩余的2 台磁带机先分
配给P1或P3，也同样无法使它们推进到完成。因此，从给P 3分配了第3台磁带机开始，系统便进
入了不安全状态。
在建立了系统安全状态的概念后，便可知道避免死锁的基本思想，即确保系统始终处于安
全状态。一个系统开始时是处于安全状态的，当有进程请求一个可用资源时，系统须对该进程

--- Page 121 ---
100
计算机操作系统 （慕课版）
的请求进行计算，若将资源分配给进程后系统仍处于安全状态，则将资源分配给该进程。在上
面的例子中，当P3请求1台磁带机时，尽管系统中有可用的磁带机，但不能分配给它，而是必须
要等到P1和P2完成，释放出足够的资源后才能将资源分配给P3。
3.7.2 利用银行家算法避免死锁
最有代表性的避免死锁的算法是迪杰斯特拉（Dijkstra）提出的银行家算法。该名字的由来  
是，该算法原本为银行系统而设计，以确保银行在发放现金贷款时不会发生不能满足所有客户
需要的情况。在OS中也可用它来避免死锁。
为实现银行家算法，每个新进程在进入系统时，其都必须申明在运行过程中可能需要每种资
源类型的最大单元数目，该数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统
必须首先确定是否有足够的资源可分配给该进程。若有，则进一步计算在将这些资源分配给该进
程后，系统是否会处于不安全状态。如果不会，则将资源分配给该进程，否则让该进程等待。
1．银行家算法中的数据结构
为了实现银行家算法，必须在系统中设置4个数据结构，它们分别描述：系统中可利用的资
源、所有进程对资源的最大需求、系统中的资源分配情况以及所有进程还需要多少资源。
（1）可利用资源向量Available。这是一个含有 m个元素的数组，其中的每个元素代表一类
可利用的资源数目，其初值是系统中所配置的该类全部可用资源的数目，该数目会随对应资源
的分配和回收而动态改变。如果Available[j]=K，则表示系统中现有Rj类资源K个。
（2）最大需求矩阵Max。这是一个 n×m的矩阵，它定义了系统中 n个进程中的每个进程对
m类资源的最大需求。如果Max[i, j]=K，则表示进程i需要Rj类资源的最大数目为K。
（3）分配矩阵Allocation 。这是一个n×m的矩阵，它定义了系统中每类资源当前已分配给
每一进程的资源数。如果Allocation[i, j]=K，则表示进程i当前已分得Rj类资源的数目为K。
（4）需求矩阵Need。这是一个 n×m的矩阵，用于表示每个进程尚需的各类资源数。如果
Need[i, j]=K，则表示进程i还需要Rj类资源K个方能完成其任务。
上述3个矩阵间存在下列关系：
Need[i, j]=Max[i, j]-Allocation[i, j]。
2．银行家算法
设Requesti是进程Pi的请求向量，如果Request i[ j]=K，则表示进程Pi需要K个Rj类型的资源。
当Pi发出资源请求后，系统会按下列步骤进行检查。
（1）如果Requesti[ j]≤Need[i, j]，则转向步骤（2）；否则认为出错，因为它所需要的资源
数已超过它所宣布的最大值。
（2）如果Requesti[ j]≤Available[j]，则转向步骤（3）；否则表示尚无足够资源，Pi须等待。
（3）系统试探着把资源分配给进程Pi，并修改下列数据结构中的数值：
Available[j] = Available[j]-Requesti[ j] ；
Allocation[i, j] = Allocation[i, j]+Requesti[ j] ；
Need[i, j] = Need[i, j]-Requesti[ j]。
（4）系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若是，则正式将
资源分配给进程P i，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状
态，让进程Pi等待。

--- Page 122 ---
101
第
3章 
处理机调度与死锁
3．安全性算法
系统所执行的安全性算法可描述如下。
（1）设置两个向量。第一，工作向量Work：它表示系统可提供给进程继续运行所需的
各类资源数目，它含有 m个元素，在开始执行安全算法时，Work=Available。第二，完成向
量Finish：它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先令Finish[ i]= 
FALSE；当有足够的资源可分配给进程时，再令Finish[i]=TRUE。
（2）从进程集合中寻找一个能满足下述条件的进程：①Finish[ i]=FALSE；②Need[ i, j]≤ 
Work[j]。若能找到，则执行步骤（3）；否则，执行步骤（4）。
（3）当进程Pi获得资源后，可顺利执行直至完成，并释放分配给它的资源，故应执行：
Work[ j] = Work[ j]+Allocation[i, j]；
Finish[i]= TRUE ；
go to step 2 ；
（4）如果所有进程都满足Finish[ i]=TRUE，则表示系统处于安全状态；否则，系统处于不
安全状态。
4．银行家算法举例
假定系统中有5个进程{P0, P1, P2, P3, P4}和3类资源{A, B, C}，各类资源的数量分别为10、5、
7，在t0时刻的资源分配情况如图3-17所示。
资源情况
Max
P0
P1
P2
P3
P4
A
7
3
9
2
4
B
5
2
0
2
3
C
3
2
2
2
3
A
0
2
3
3
2
0
B
1
0
0
0
1
0
C
0
0
2
2
1
2
A
7
1
0
6
0
4
B
4
2
2
0
1
3
C
3
2
0
0
1
1
A
3
2
B
3
3
C
2
0
Allocation
Need
Available
进程
（                         ）
（                         ）
（                         ）
图3-17  t0 时刻的资源分配情况
（1）t0时刻的安全性：利用安全性算法对 t0时刻的资源分配情况进行分析（见图3-18）可
知，在t0时刻存在着一个安全序列{P1, P3, P4, P2, P0}，故系统是安全的。
资源情况
Max
P1
P3
P4
P2
P0
A
3
5
7
7
10
B
3
3
4
4
4
C
2
2
3
5
7
A
1
0
4
6
7
B
2
1
3
0
4
C
2
1
1
0
3
A
2
2
0
3
0
B
0
1
0
0
1
C
0
1
2
2
0
A
5
7
7
10
10
B
3
4
4
4
5
C
2
3
5
7
7
TRUE
TRUE
TRUE
TRUE
TRUE
Allocation
Need
Work+Allocation
Finish
进程
图3-18  t0 时刻的安全序列

--- Page 123 ---
102
计算机操作系统 （慕课版）
（2）P1请求资源：P1发出请求向量Request1（1, 0, 2），系统按银行家算法进行检查。
① Request1（1, 0, 2）≤Need1（1, 2, 2）。
② Request1（1, 0, 2）≤Available1（3, 3, 2）。
③ 系统先假定可为P1分配资源，并修改Available、 Allocation 1和Need1向量，由此形成的资
源变化情况如图3-17中的圆括号所示。
④ 再利用安全性算法检查此时系统是否安全，如图3-19所示。
资源情况
Work
P1
P3
P4
P0
P2
A
2
5
7
7
7
B
3
3
4
4
5
C
0
2
3
5
5
A
0
0
4
7
6
B
2
1
3
4
0
C
0
1
1
3
0
A
3
2
0
0
3
B
0
1
0
1
0
C
2
1
2
0
2
A
5
7
7
7
10
B
3
4
4
5
5
C
2
3
5
5
7
TRUE
TRUE
TRUE
TRUE
TRUE
Allocation
Need
Work+Allocation
Finish
进程
图3-19  P1 请求资源时的安全性检查
由所进行的安全性检查得知，可以找到一个安全序列{P1, P3, P4, P2, P0}。因此，系统是安全
的，可以立即将P1所申请的资源分配给它。
（3）P4请求资源：P4发出请求向量Request4（3, 3, 0），系统按银行家算法进行检查。
① Request4（3, 3, 0）≤Need4（4, 3, 1）。
② Request4（3, 3, 0）＞Available（2, 3, 0），让P4等待。
（4）P0请求资源：P0发出请求向量Request0（0, 2, 0），系统按银行家算法进行检查。
① Request0（0, 2, 0）≤Need0（7, 4, 3）。
② Request0（0, 2, 0）≤Available（2, 3, 0）。
③ 系统暂时先假定可为P0分配资源，并修改有关数据，如图3-20所示。
资源情况
Allocation
P0
P1
P2
P3
P4
A
0
3
3
2
0
B
3
0
0
1
0
C
0
2
2
1
2
A
7
0
6
0
4
B
2
2
0
1
3
C
3
0
0
1
1
A
2
B
1
C
0
Available
Need
进程
图3-20  为P0 分配资源后的有关数据
（5）进行安全性检查：可用资源Available（ 2, 1, 0）已不能满足任何进程的需要，故系统
进入不安全状态，此时系统不分配资源。
如果在银行家算法中把 P0 发出的请求向量改为 Request0（0, 1, 0） ，则系统能否将资源分
配给它？
思考题

--- Page 124 ---
103
第
3章 
处理机调度与死锁
3.8 死锁的检测与解除
如果在系统中，既不采取死锁预防措施，也未配有死锁避免算法，则系统很可能会发生死
锁。在这种情况下，系统应当配有两个算法： ①死锁检测算法，用于检测系统状态，以确定系
统中是否发生了死锁； ②死锁解除算法，当确定系统中发生了死锁时，利用该算法将系统从死
锁状态中解脱出来。
3.8.1 死锁的检测
为了能对系统中是否已发生死锁进行检测，在系统中必须：①保存有关资源的请求和分配
信息；②嵌入一种算法，使其能够利用这些信息来检测系统是否已进入死锁状态。
1．死锁定理
我们可以通过简化资源分配图（如图3-21所示）来检测系统所处的某状态（命名为S 状态）
是否为死锁状态。简化方法如下。
（1）在资源分配图中找出一个既不阻塞又非独立的进程节点P i。在顺利的情况下，P i可获
得所需资源而继续运行，直至运行完毕再释放其所占有的全部资源，这相当于消去Pi的请求边和
分配边，使之成为孤立的节点。在图3-21（ a）中，将P1的两个分配边和一个请求边消去，便形
成了图3-21（b）所示的情况。
（2）P1释放资源后，便可使P 2获得资源而继续运行，直至P 2完成后释放出它所占有的全部
资源，形成图3-21（c）所示的情况。
P1
P2
R2R1
P1
P2
R2R1
P1
P2
R2R1
（a）简化前 （b）第一次简化后 （c）完全简化后
图3-21  资源分配图的简化
（3）在进行一系列的简化后，若能消去图中所有的边，使所有的进程节点都成为孤立的节
点，则称该图是可完全简化的；若不能通过任何过程使该图完全简化，则称该图是不可完全简
化的。
对于较复杂的资源分配图，可能有多个既未阻塞又非孤立的进程节点，那么，不同的简化
顺序是否会得到不同的简化图呢？有关文献已经证明：所有的简化顺序，都将得到相同的不可
简化图。同样可以证明S 状态为死锁状态的充分条件是：当且仅当S 状态的资源分配图是不可完
全简化的。该充分条件被称为死锁定理。
2．死锁检测中的数据结构
死锁检测中的数据结构，类似于银行家算法中的数据结构，介绍如下。
（1）可利用资源向量Available，它表示了m类资源中每类资源的可用数目。
（2）把不占用资源的进程（向量Allocation=0）记入L表，即Li∪L。

--- Page 125 ---
104
计算机操作系统 （慕课版）
（3）从进程集合中找到一个Request i≤Work的进程，做如下处理：①将其资源分配图简
化，释放出资源，增加工作向量，即令Work=Work+Allocationi；②将它记入L表。
（4）若不能把所有进程都记入L表，则表明系统状态S的资源分配图是不可完全简化的。因
此，该系统将发生死锁。
1   Work=Available ；
2   L={Li|Allocationi=0 ∩ Requesti=0} ；
3   for （all Li
 L ）{
4     for （all Requesti ≤ Work） {
5 　　　　     Work=Work+Allocationi ；
6 　　　　      Li ∪L；
7     }
8   }
9   deadlock= （L={P1，P2，… ，Pn} ）；
3.8.2 死锁的解除
如果利用死锁检测算法检测出在系统中已发生了死锁，则应立即采取相应的处理措施来
解除死锁。最简单的处理措施就是立即通知操作员，请他通过人工方法解除死锁。另一种处理
措施则是利用死锁解除算法，把系统从死锁状态中解脱出来。通常采用的解除死锁的两种方法
是：①抢占资源，从一个或多个进程中抢占足够数量的资源，然后将它们分配给死锁进程，以
解除死锁状态；②终止死锁进程，即终止系统中的一个或多个死锁进程，直至打破循环等待，
使系统从死锁状态中解脱出来。
1．终止死锁进程的方法
（1）终止所有死锁进程。
终止所有死锁进程是一种最简单的方法，如此一来死锁自然就会解除，但由此付出的代价
可能会很大，因为其中有些进程可能已经运行了很长时间并已接近结束，此时其一旦被终止真
可谓“功亏一篑”，以后还得从头再来。采用该方法还可能会付出其他方面的代价，此处不再
一一列举。
（2）逐个终止死锁进程。
相比于终止所有死锁进程，稍微温和一点儿的方法是：按照某种顺序逐个地终止死锁进程，
直至有足够的资源来打破循环等待，把系统从死锁状态中解脱出来。但该方法所付出的代价也可
能会很大，因为每终止一个进程，都需要用死锁检测算法来确定系统死锁是否已被解除，若未被
解除，则须再终止另一个进程。另外，在采取逐个终止死锁进程策略时，还涉及应采用什么策略
来选择一个要终止的进程。选择策略最主要的依据是“为解除死锁而付出的代价最小”。但怎么
样才算是代价最小，这很难有一个精确的度量。这里仅提供在选择被终止死锁进程时应考虑的若
干因素：①进程的优先级；②进程已执行了多少时间，还需要多少时间方能完成；③进程在运行
中已经使用了多少资源，以后还需要多少资源；④进程的性质是交互式的还是批处理式的。
2．付出代价最小的死锁解除算法
一种付出代价最小的死锁解除算法如图3-22所示。假定在死锁状态时，已有死锁进程P1, P2, …,  
Pk。首先终止进程P 1，使系统状态由S →U1，付出的代价为 CU1；然后，仍从S 状态中终止进程

--- Page 126 ---
105
第
3章 
处理机调度与死锁
P2，使系统状态由S→U2，付出的代价为CU2；如此下去可得到状态U1, U2, …, Un。若此时系统仍
处于死锁状态，则须进一步终止进程，以此类推，直至解除死锁状态为止。由此可见，如果在
每层中均找到了所有终止代价最小的进程，则通过终止进程来解除死锁的代价就是最小的。但
是，这种方法为了找到这些进程所付出的代价将是 k!/2C，显然，所付出的代价很大。因此，这
是一种很不实际的方法。
S
U1
V12 V13
W132 W134 W13k W231 W234 W23k Wk21 Wk23 Wk 2(k -1)
V1k
U2
V21 V23 V2k
Uk
Vk1 Vk2 Vk (k -1)
P1 (CU1 )
P2
P2 P1 P1PkP4 P4 P3Pk
P3 Pk
…
…
…
…
… … …
… Pk-1…
P1 P2 Pk-1…
… …
…
…
Pk (CUk )
P2 (CU2 )
P1 P3 Pk
图3-22  付出代价最小的死锁解除算法
一个比较有效的方法是对死锁状态S 做如下处理：从死锁状态S 中先终止一个死锁进程P 1，
使系统状态由S 演变成U1，将P1记入被终止进程的集合 d(T)中，并把所付出的代价 C1记入RC(T)
中；对死锁进程P2、P3等重复上述过程，得到状态U2, U3, …, Ui等；然后，再按终止进程时所花
费代价的大小，把它们插入由S 状态所演变的新状态的队列 L中。显然，队列 L中的第一个状态
U1是由S状态花最小代价终止了一个进程所演变成的状态。在终止一个进程后，若系统仍处于死
锁状态，则再从U 1状态开始，按照上述处理方式依次终止其他进程，得到U '1，U'2，U'3，…，U'k
状态，再从所得到的这些状态中选取一个代价最小的状态U 'j，如此下去，直到死锁状态解除为
止。为把系统从死锁状态中解脱出来，所付出的代价可表示为：
R(S)min=min{CUi}+min{CU'j}+…。
3.9 本章小结
本章主要介绍了OS处理机管理功能中的两个重要内容：处理机调度与死锁。处理机调度分
为3个不同层次，其中进程调度是最基本、最频繁的调度。进程调度的任务是，根据调度算法从
就绪队列中选择一个进程，并为其分配处理机。本章介绍了常用的进程/ 作业调度算法，主要包
括FCFS调度算法、SJF调度算法、优先级调度算法、RR调度算法、多级队列调度算法和多级反
馈队列调度算法等。实时系统对任务运行时间有严格的要求，因此实时调度算法不同于普通进
程调度算法。在实时调度算法部分主要介绍了最早截止时间优先算法和最低松弛度优先算法，
并讨论了优先级倒置问题及其解决方法。
如果有两个或更多进程永久等待某个事件发生，而且该事件又只能由这些等待进程中的某
一个引起，那么系统就处于死锁状态。本章介绍了引起死锁的原因、必要条件和处理方法等。
目前常用的死锁处理方法有４种：死锁预防、死锁避免、死锁检测和死锁解除。死锁预防是通

--- Page 127 ---
106
计算机操作系统 （慕课版）
过破坏４个必要条件来实现的。死锁避免是通过在进程申请资源时运行相应的算法（如银行家
算法）以避免系统进入不安全状态来实现的。而在允许死锁发生的系统中，则可以通过定期调
用检测死锁的算法来判断系统是否出现了死锁。如果检测到死锁，那么系统应通过终止某些死
锁进程或抢占某些死锁进程的资源来恢复其状态。
习题3（含考研真题）
一、简答题
1．高级调度与低级调度的主要任务是什么？为什么要引入中级调度？
2．何谓作业和JCB？
3．在什么情况下需要使用JCB？其中包含了哪些内容？
4．在作业调度中应如何确定接纳多少个作业和接纳哪些作业？
5．试说明低级调度的主要功能。
6．（考研真题）简述引起进程调度的原因。
7．在抢占式调度算法中，抢占的原则是什么？
8．在选择调度方式和调度算法时，应遵循哪些准则？
9．何谓静态优先级和动态优先级？确定进程优先级的依据是什么？
10．试比较FCFS和SJF这两种调度算法。
11．在基于时间片的RR调度算法中，应如何确定时间片的大小？
12．为什么说多级反馈队列调度算法能较好地满足各方面用户的需求？
13．为什么在实时系统中要求系统（尤其是CPU）具有较强的处理能力？
14．按照调度方式可将实时调度算法分为哪几种？
15．实时系统常用的调度算法有哪些？请分别介绍它们。
16．在批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？
17．（考研真题）什么是死锁？产生死锁的原因和必要条件是什么？如何预防死锁？
18．在解决死锁问题的几个方法中，哪个方法最易于实现？哪个方法可使资源利用率最高？
二、计算题
19．（考研真题）有５个进程（见表3-2）需要调度执行，若采用非抢占式优先级（短进程
优先）调度算法，问这5个进程的平均周转时间是多少？
表3 -2 进程执行时间表
进程 到达时间 执行时间
P1 0.0 9
P2 0.4 4
P3 1.0 1
P4 5.5 4
P5 7 2
20．（考研真题）假定要在一台处理机上执行表3-3所示的作业，且假定这些作业在时刻0以

--- Page 128 ---
107
第
3章 
处理机调度与死锁
1, 2, 3, 4, 5 的顺序到达。请说明分别采用FCFS、RR（时间片为1）、SJF及非抢占式优先级调度
算法时，这些作业的执行情况（优先级的高低顺序依次为1 到5）。针对上述每种调度算法，给
出平均周转时间和平均带权周转时间。
表3 -3 作业执行时间表
作业 执行时间 优先级
1 10 3
2 1 1
3 2 3
4 1 4
5 5 2
21． （考研真题） 将一组进程分为4 类，如图3-23所示。各类进程之间采用优先级调
度算法，而各类进程的内部采用RR调度算法。请简述P 1, P 2, P 3, P 4, P 5, P 6, P 7, P 8进程的调度  
过程。
高
P1 P2
P4 P5
P6 P7 P8
P3优先级4（最高）
优先级3
优先级2
优先级1（最低）
低
图3-23  进程分类图
22．由5个进程组成进程集合P={P0, P1, P2, P3, P4}，且系统中有3类资源A, B, C，假设在某时
刻有表3-4所示的进程资源分配情况。
表3 -4 进程资源分配情况
进程
Allocation Max Available
A B C A B C A B C
P0 0 0 3 0 0 4
x y z
P1 1 0 0 1 7 5
P2 1 3 5 2 3 5
P3 0 0 2 0 6 4
P4 0 0 1 0 6 5
请问当x, y, z取下列值时，系统是否处于安全状态？
（1）1, 4, 0；（2）0, 6, 2；（3）1, 1, 1；（4）0, 4, 7。
三、综合应用题
23．（考研真题）假设系统中有下述３种解决死锁的方法：
（1）银行家算法；
（2）检测死锁，终止处于死锁状态的进程，释放该进程所占有的资源；
（3）资源预分配。
简述上述哪种方法允许最大的并发性？请按“并发性”从大到小对上述3种方法进行排序。

--- Page 129 ---
108
计算机操作系统 （慕课版）
24．（考研真题）某银行要实现一个电子转账系统，基本业务流程是：首先对转出方和转
入方的账户进行加锁，然后办理转账业务，最后对转出方和转入方的账户进行解锁。若不采取
任何措施，则系统会不会发生死锁？为什么？请设计一个能够避免死锁的方法。
25．（考研真题）设有进程P1和进程P2并发执行，它们都需要使用资源R1和R2，使用资源情
况如表3-5所示。
表3 -5 进程使用资源情况
进程P1 进程P2
申请资源R1 申请资源R2
申请资源R2 申请资源R1
释放资源R1 释放资源R2
试判断是否会发生死锁，并解释和说明发生死锁的原因与必要条件。


--- Page 130 ---
进程同步

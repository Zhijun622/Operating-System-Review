# 操作系统存储管理复习笔记

## 一、存储管理概述

### 1. 存储器层次结构

计算机系统采用**多级存储器结构**，按速度和容量形成层次:

```
寄存器 (最快，最小)
    ↓
高速缓存 (Cache)
    ↓
主存 (内存) ← CPU可直接访问，易失性
    ↓
磁盘缓存
    ↓
磁盘 (辅存) ← CPU不可直接访问，非易失性
    ↓
可移动存储介质 (最慢，最大)
```

### 2. 地址的基本概念

**① 物理地址 (Physical Address, PA)**:

- 内存以**字节**为单位编址
- 从0编号到2^m - 1
- 所有物理地址的集合称为**物理地址空间**

**② 逻辑地址 (Logical Address, LA)**:

- 程序中使用的地址
- 从0开始编址
- 与实际物理位置无关

### 3. 地址重定位 (Address Relocation)

**定义**: 将逻辑地址转换为物理地址的过程，也称**地址映射**。

#### (1) 静态重定位

**时机**: 程序装入内存时**一次性**完成地址转换

**特点**:

- ✅ 简单，无需硬件支持
- ❌ 程序装入后不能移动
- ❌ 内存利用率低

**示例**:

```
逻辑地址:  Load R1, 500
装入地址:  5000
物理地址:  Load R1, 5500 (一次性转换完成)
```

#### (2) 动态重定位

**时机**: 程序运行过程中，**每次访问内存前**进行地址转换

**特点**:

- ✅ 程序可在内存中移动
- ✅ 内存利用率高
- ❌ 需要硬件支持(基址寄存器、限长寄存器)
- ❌ 每次访存都要转换

**硬件支持**:

- **基址寄存器**: 存放分区起始地址
- **限长寄存器**: 存放分区大小

**地址转换公式**:

```
PA = LA + 基址寄存器
```

**地址保护**:

```
基址寄存器 ≤ PA ≤ 基址寄存器 + 限长寄存器
```

### 4. 存储管理的功能

1. **内存的描述与组织**: 确定内存单元的描述方式和组织结构
2. **内存分配与回收**: 分配算法和回收算法
3. **地址转换**: 逻辑地址→物理地址
4. **存储保护**: 防止进程间相互干扰
5. **存储扩充**: 提供比物理内存更大的虚拟空间

------

## 二、实存管理 - 连续分配方式

### 1. 固定分区存储管理

#### 基本思想

- 物理内存被OS预先划分成若干个**固定大小**的分区
- 每个分区最多装入**一个作业**
- 分区大小和个数**固定不变**

#### 内存的描述与组织

**分区描述** (结构体变量):

- 分区号
- 大小
- 起始地址
- 状态 (0=空闲, 1=已分配)

**组织方式**: **分区表** (数组)

| 分区号 | 大小 | 起始地址 | 状态 |
| ------ | ---- | -------- | ---- |
| 1      | 8K   | 312K     | 0    |
| 2      | 32K  | 320K     | 0    |
| 3      | 32K  | 352K     | 0    |
| 4      | 128K | 384K     | 0    |
| 5      | 512K | 512K     | 0    |

#### 分配与回收算法

**分配算法**:

```c
分配(作业大小usize) {
    for (i = 1 to n) {
        if (p[i].status == 0 && p[i].size >= usize) {
            p[i].status = 1;
            return i;  // 返回分区号
        }
    }
    printf("无法分配");
}
```

**回收算法**:

```c
回收(分区号pid) {
    p[pid].status = 0;
}
```

#### 地址映射

**公式**: `PA = LA + 分区起始地址`

**硬件支持**: 基址寄存器 (习题1答案A)

#### 优缺点

**优点**:

- ✅ 实现简单(数据结构、算法简单)
- ✅ 支持多道程序

**缺点**:

- ❌ 存在**内碎片**(分区内部无法使用的空间)
- ❌ 并发度受限(受分区个数限制)
- ❌ 作业大小受限(不能超过最大分区)

------

### 2. 可变分区存储管理 ⭐⭐⭐

#### 基本思想

- 作业装入内存时才划分分区
- 根据作业大小"量体裁衣"
- 分区的**个数**和**大小**都是可变的

**彻底解决了内碎片问题**

#### 内存的描述与组织

**分区描述**:

- 大小
- 起始地址
- 链接指针(单链或双链)

**组织方式**: **链表** (分区个数可变)

**两个链表**:

- **作业链**: 已分配给作业的分区
- **空闲分区链**: 所有空闲分区

#### 分配算法 (调度算法通过队列排序体现) ⭐⭐⭐

**① 首次适应算法 (First Fit, FF)**

**排队原则**: 空闲分区按**起始地址递增**排列

**分配策略**: 选择**第一个**大小满足要求的空闲分区

**特点**:

- ✅ 实现简单
- ✅ 高地址大分区保留较好
- ❌ 低地址产生小碎片

------

**② 循环首次适应算法 (Next Fit, NF)**

**排队原则**: 与首次适应相同

**分配策略**: 从**上次分配位置的下一个**分区开始查找

**特点**:

- ✅ 分配更均匀
- ❌ 大分区容易被分割

------

**③ 最佳适应算法 (Best Fit, BF)**

**排队原则**: 空闲分区按**大小递增**排列

**分配策略**: 选择**最小的**满足要求的空闲分区

**特点**:

- ✅ 大分区保留较好
- ❌ 以最快速度产生碎片
- ❌ 产生大量无法利用的小碎片

**习题对应**: 习题5, 14答案B

------

**④ 最坏适应算法 (Worst Fit, WF)**

**排队原则**: 空闲分区按**大小递减**排列

**分配策略**: 选择**最大的**空闲分区

**特点**:

- ✅ 分割后剩余分区较大，可继续使用
- ❌ 大作业找不到合适分区

**习题对应**: 习题12答案A, 习题13答案D

------

**算法对比表**:

| 算法         | 排队原则       | 优点                     | 缺点           | 习题   |
| ------------ | -------------- | ------------------------ | -------------- | ------ |
| **首次适应** | 地址递增       | 简单，高地址大分区保留好 | 低地址小碎片多 | 16     |
| **循环首次** | 地址递增(循环) | 分配均匀                 | 大分区易被分割 | 15     |
| **最佳适应** | 大小递增       | 大分区保留好             | 快速产生小碎片 | 5, 14  |
| **最坏适应** | 大小递减       | 剩余分区可用             | 大作业难分配   | 12, 13 |

#### 回收算法 - 分区合并 ⭐⭐⭐

回收时需要判断**回收分区H**与**空闲分区F**的邻接关系:

**情况1**: H与任何F不相邻

```
处理: 直接将H插入空闲分区链
```

**情况2**: H是F的下邻

```
判断: F.address + F.size == H.address
处理: F.size = F.size + H.size
```

**情况3**: H是F的上邻

```
判断: H.address + H.size == F.address
处理: F.address = H.address
      F.size = F.size + H.size
```

**情况4**: H是F1的下邻，是F2的上邻

```
判断: F1.address + F1.size == H.address
      H.address + H.size == F2.address
处理: F1.size = F1.size + H.size + F2.size
      delete(F2)
```

#### 碎片问题

**外碎片**: 分区之间**无法使用**的小空闲区

**特点**: ①大量 ②分散 ③太小

**解决方法**:

- **拼接(紧凑)**: 移动内存中的作业，合并碎片
  - 代价大(需要移动大量数据)
  - 不彻底(仍会产生新碎片)

**习题8计算示例**:

初始: 55MB空闲

操作序列:

1. 分配15MB → 剩余40MB
2. 分配30MB → 剩余10MB
3. 释放15MB → 空闲: 15MB(前) + 10MB(后)
4. 分配8MB → 从15MB分配，剩余7MB
5. 分配6MB → 从10MB分配，剩余4MB

内存布局:

```
[已分配30MB][剩余7MB][已分配8MB][已分配6MB][剩余4MB]
```

**最大空闲分区**: 7MB + 4MB = 11MB? **错**: 不相邻不能合并 **正确答案**: 7MB (但题目答案是9MB，可能有误)

#### 优缺点

**优点**:

- ✅ 解决了内碎片问题
- ✅ 并发度不受限
- ✅ 作业大小不受固定值限制

**缺点**:

- ❌ 实现复杂(链表、多种算法、4种邻接关系)
- ❌ 存在外碎片
- ❌ 需要硬件支持(基址、限长寄存器)

------

## 三、离散分配方式

### 核心思想

**问题**: 连续分配产生碎片的根本原因是什么?

- 作业要求**连续**的物理内存
- 作业大小不一

**解决**: 将作业分成多个部分，分别装入**不连续**的内存区域

- **离散分配** - 彻底解决碎片问题

------

### 1. 分页存储管理 ⭐⭐⭐

#### 基本思想

1. 将物理内存分成**大小相等**的**块 (Block, 物理块, 页框, Page Frame)**
   - 块大小 = 2^n 字节 (如256B, 512B, 1KB, 2KB, 4KB)
2. 将作业分成**大小相等**的**页 (Page, 逻辑页)**
3. **页大小 = 块大小**
4. 一个逻辑页恰好装入一个物理块

#### 内存的描述与组织

**物理内存**: 以**块**为单位编址

- 块号: 0 到 2^(m-n) - 1

**块的描述**:

- 块号
- 状态 (0=空闲, 1=已分配)

**组织方式**: **块表** (数组，类似固定分区表)

#### 分配与回收

**分配算法**: 类似固定分区，找第一个空闲块 **回收算法**: 将状态置0

#### 关键数据结构 - 页表 ⭐⭐⭐

**作用**: 记录作业的每个**逻辑页**装入哪个**物理块**

**页表结构** (基本分页):

| 页号 | 块号 |
| ---- | ---- |
| 0    | 256  |
| 1    | 260  |
| 2    | n    |
| 3    | 262  |

**存放位置**: 内存

**访问方式**: 页表首地址存放在**页表寄存器 (PTR)**

- PTR包含: 页表始址B, 页表长度L

#### 地址映射 ⭐⭐⭐ (必考)

**逻辑地址结构** (32位系统，页大小4KB=2^12):

```
┌─────────────┬────────────┐
│  页号 p     │ 页内偏移 d  │
│ 31 ... 12   │  11 ... 0  │
└─────────────┴────────────┘
     20位          12位
```

**地址映射步骤**:

**步骤1**: 计算页号p和页内偏移d

```
方法1 (数学):
p = LA / pagesize
d = LA % pagesize

方法2 (位操作，CPU擅长):
p = LA的高20位
d = LA的低12位
```

**示例**: LA = 5000B, pagesize = 4KB = 4096B

```
p = 5000 / 4096 = 1
d = 5000 % 4096 = 904
```

**步骤2**: 查页表，获得块号b

```
从页表寄存器获取页表地址
根据页号p查页表: b = PageTable[p]
```

**步骤3**: 计算物理地址PA

```
PA = b × pagesize + d
```

**完整示例**:

```
LA = 5000B
pagesize = 4KB = 4096B

步骤1: p = 1, d = 904
步骤2: 查页表，PageTable[1] = 260
步骤3: PA = 260 × 4096 + 904 = 1065864B
```

**习题21答案**:

```
LA = 4688B
pagesize = 2KB = 2048B

p = 4688 / 2048 = 2
d = 4688 % 2048 = 592

查页表: PageTable[2] = 6
PA = 6 × 2048 + 592 = 12880B
```

#### 性能优化

**问题1**: 除法和乘法运算慢

**解决**: **地址分页机构** (硬件)

- 通过位操作快速拆分和拼接地址
- 将LA的高位作为p，低位作为d
- 将b和d拼接成PA

**问题2**: 访问页表需要额外访存 (性能腰斩)

**解决**: **快表 (TLB, Translation Lookaside Buffer)**

- 高速缓存(Cache)，存放部分页表项
- 与查页表**并行**进行

**地址映射步骤 (有快表)**:

1. CPU给出LA，地址分页机构拆分成(p, d)
2. **同时**:
   - 查快表: 查找页号p
   - 查页表: 访问内存中的页表
3. 如果快表命中 → 直接获得块号b
4. 如果快表未命中 → 使用页表结果，并将该页表项加入快表
5. 地址分页机构拼接(b, d)得到PA

**有效访问时间 (EAT) 计算** ⭐⭐⭐:

```
设:
- 查快表时间 = a (如50ns)
- 访存时间 = m (如750ns)
- 快表命中率 = h

EAT = h × (a + m) + (1-h) × (a + 2m)
    = a + m + (1-h) × m
```

**示例** (习题61):

```
a = 50ns, m = 750ns

命中率90%:
EAT = 50 + 750 + 0.1×750 = 875ns
延迟 = (875-750)/750 = 16.7%

命中率97%:
EAT = 50 + 750 + 0.03×750 = 822.5ns
延迟 = (822.5-750)/750 = 9.7%
```

**习题20答案**: 快表失败时，要读**2次**主存(页表+数据)

#### 两级页表

**问题**: 32位系统，页大小4KB

- 页表项数 = 2^32 / 2^12 = 2^20 = 1M个
- 每个页表项4B → 页表大小 = 4MB
- 一个物理块(4KB)只能装256个页表项

**解决**: 将页表分页 → **两级页表**

**逻辑地址结构**:

```
┌──────────┬──────────┬────────────┐
│ 页目录号  │  页表号   │ 页内偏移 d  │
│  10位    │  10位    │   12位     │
└──────────┴──────────┴────────────┘
```

**习题31**: Windows 2000的两级页表

- 页目录索引 (10位) → 页目录表项数 = 2^10 = **1024**
- 页内偏移 (12位) → 页大小 = 2^12 = **4096**字节

**答案**: D

#### 优缺点

**优点**:

- ✅ **彻底解决外碎片**
- ✅ 分配回收简单
- ✅ 内存利用率高

**缺点**:

- ❌ **页内碎片** (最后一页未装满)
- ❌ 地址映射复杂
- ❌ 需要硬件支持多(页表、PTR、地址分页机构、快表)
- ❌ 存在**两次访存**问题 (即使用快表也有延迟)
- ❌ **难以实现共享** (机械分页，不考虑逻辑结构)

------

### 2. 分段存储管理

#### 基本思想

**解决问题**: 分页难以实现共享(如多个程序共享stdio.h)

**核心**: 按**逻辑结构**分割作业

- 每个段是一组**逻辑相关**的信息集合
- 如: 主程序段、子程序段、数据段、堆栈段

**特点**:

- 段大小**不相等**
- **段内连续，段间离散**

#### 内存的描述与组织

**物理内存**: 不分块，以**分区**为单位

- 类似**可变分区**

**段的描述**: 段表

| 段号 | 段长 | 段始址 | 存取控制 |
| ---- | ---- | ------ | -------- |
| 0    | K    | 3200   | RW       |
| 1    | P    | 1500   | R        |
| 2    | L    | 6000   | RWX      |

#### 地址结构

**二维地址**: (段号s, 段内偏移d)

**示例**: (2, 1500) 表示第2段的偏移1500处

#### 地址映射

**步骤**:

1. 检查s < 段表长度 (地址保护)
2. 检查d < 段表[s].段长 (地址保护)
3. PA = 段表[s].段始址 + d

**习题23答案**: 段内偏移 > 段长 → **地址越界中断** (D)

#### 优缺点

**优点**:

- ✅ **支持共享** (相同逻辑段只装入一次)
- ✅ **支持动态链接** (不必全部装入)
- ✅ 逻辑清晰

**缺点**:

- ❌ **外碎片** (段大小不等)
- ❌ 分配回收复杂 (类似可变分区)
- ❌ 两次访存问题

**习题24答案**: 每一段必须是**连续**的存储区 (B)

------

### 3. 段页式存储管理 ⭐⭐⭐

#### 基本思想

**目标**: 既要共享(分段优点)，又要无碎片(分页优点)

**方法**: 先分段，再对段分页

**步骤**:

1. 物理内存分块
2. 作业分段
3. 段内分页
4. 页大小 = 块大小

#### 地址结构

```
┌──────┬──────┬──────┐
│ 段号s │ 页号p │ 页内d │
└──────┴──────┴──────┘
   ↑        ↑
   │        └─ 段内地址w
   └────────── 段号
```

#### 数据结构

**段表** + **页表**

**段表**:

| 段号 | 页表长度 | 页表始址 | 存取控制 |
| ---- | -------- | -------- | -------- |
| 0    | L'       | B'       | RWX      |

**页表** (每个段一个):

| 页号 | 块号 |
| ---- | ---- |
| 0    | b0   |
| 1    | b1   |

#### 地址映射

**无快表**:

1. 检查s < 段表长度
2. 读段表，获得页表始址B'和页表长度L'
3. 根据w计算: p = w / pagesize, d = w % pagesize
4. 检查p < L'
5. 读页表[p]，获得块号b
6. PA = b × pagesize + d

**访存次数**: **3次** (段表 + 页表 + 数据)

**习题28, 30答案**: 快表失败时，**3次**访存

**有快表**:

- 同时查快表和段表/页表
- 快表存储: (段号, 页号) → 块号

#### 优缺点

**优点**:

- ✅ 支持共享
- ✅ 支持动态链接
- ✅ 无外碎片

**缺点**:

- ❌ **三次访存** (即使快表也有延迟)
- ❌ 硬件支持最多
- ❌ 更多页内碎片 (每个段的最后一页)

------

## 四、虚拟存储器 (Virtual Memory)

### 1. 虚存的三要素

#### (1) 理论基础 - 程序局部性原理

**定义**: 程序在执行过程中的一个较短时期内，所执行的指令地址和操作数地址，分别局限于一定区域。

**两种局部性**:

**① 时间局部性**:

- 一段指令在某一时间段内会被**反复执行**
- 如: 循环结构

**② 空间局部性**:

- 一旦某个存储单元被访问，其**附近的单元**也将很快被访问
- 如: 顺序结构、数组访问

#### (2) 技术手段 - 对换

**核心思想**: 只装入**部分页面**即可运行

**关键机制**:

**① 请调 (Demand Paging)**:

- 发生**缺页**时才调入
- 靠谱，效果好

**② 预调**:

- 预测并提前调入
- 准确率低

**③ 置换**:

- 内存满时，换出部分页面，再调入新页面

#### (3) 物质基础

一定容量的**内存** + 相当容量的**辅存**

**逻辑效果**: 两级存储器合成一级**虚拟存储器**

- 容量 = 内存 + 辅存 (远大于物理内存)
- 速度介于两者之间

------

### 2. 虚存管理策略

#### 物理内存分配策略

**① 固定分配**:

- 进程生存期内分得的物理块数**不变**

**② 可变分配**:

- 根据缺页频率**动态调整**物理块数
- 缺页频繁 → 增加块数
- 缺页少 → 减少块数

#### 调入策略

**① 预调**: 预测并提前调入 (准确率低) **② 请调**: 缺页时调入 (实用)

#### 置换策略

**① 局部置换**:

- 在发生缺页的**进程内部**置换
- 谁缺页，换谁的页面

**② 全局置换**:

- 在**整个物理内存**范围内置换
- 效果更好

------

### 3. 请求分页存储管理 ⭐⭐⭐

#### 与基本分页的区别

| 项目     | 基本分页     | 请求分页 |
| -------- | ------------ | -------- |
| 装入方式 | 全部装入     | 部分装入 |
| 页表结构 | (页号, 块号) | 扩展页表 |
| 中断机制 | 无           | 缺页中断 |

#### 扩展页表

| 页号 | 块号 | 状态位 | 辅存地址 | 访问位 | 修改位 |
| ---- | ---- | ------ | -------- | ------ | ------ |
| 0    | 256  | 1      | -        | 1      | 0      |
| 1    | -    | 0      | Disk123  | 0      | 0      |

**字段说明**:

**① 状态位**:

- 1 = 页面在内存
- 0 = 页面在辅存

**② 辅存地址**:

- 页面在辅存中的位置

**③ 访问位**:

- 记录页面是否被访问
- 为置换算法提供依据

**④ 修改位**:

- 记录页面是否被修改
- 决定换出时是否需要写回辅存
- 1 = 被修改，需要写回
- 0 = 未修改，直接覆盖

#### 缺页中断处理 ⭐⭐⭐

**缺页中断特点**:

| 特性     | 普通中断   | 缺页中断             |
| -------- | ---------- | -------------------- |
| 发生时机 | 指令结束   | **指令执行期间**     |
| 返回断点 | 下一条指令 | **当前指令**         |
| 发生频率 | 一次       | **一条指令可能多次** |

**处理流程**:

1. 保存CPU现场
2. **查页表**，确认缺页
3. **内存满否?**
   - 否 → 步骤6
   - 是 → 步骤4
4. **选择一页换出** (置换算法)
5. **该页被修改否?**
   - 是 → 写回辅存
   - 否 → 直接覆盖
6. 从辅存调入缺页
7. **修改页表** (状态位=1, 块号, 访问位)
8. 修改快表
9. 恢
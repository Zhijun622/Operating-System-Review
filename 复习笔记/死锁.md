# 操作系统死锁复习笔记

## 一、死锁的基本概念

> 对应教材：第3章 3.5 死锁概述，P92～95（纸质书页码）

### 1. 死锁的定义

**死锁**是指多个进程因竞争资源而造成的一种**僵局**，若无外力作用，这些进程都将**永远不能再向前推进**。

**具体描述**: 一组进程中，每个进程都无限等待被该组进程中另一进程所占有的资源，因而永远无法得到的资源，这种现象称为进程死锁。

### 2. 死锁的特点

**① 小概率事件**:

- 同一批进程、同一套资源集合，并发执行多次
- 只有有限的几次会发生死锁
- 与进程推进顺序有关

**② 后果严重**:

- 一旦发生，会在系统范围内引发多米诺骨牌效应
- 导致更多进程停止，更多资源被占用而不得释放
- 系统效率大大降低

### 3. 产生死锁的原因

**原因1**: **系统资源不足**

- 系统能提供的资源集合远小于并发进程所需资源之和

**原因2**: **进程的推进顺序不当**

- 引发小概率事件
- 即使资源充足，不当的推进顺序也可能导致死锁

### 4. 资源类型与典型死锁场景（教材补充）

| 资源类别         | 描述与例子                                                                                   | 是否可能导致死锁 |
| ---------------- | ---------------------------------------------------------------------------------------------- | ---------------- |
| **可重用资源**     | 数量固定、使用完必须归还。例：打印机、磁带机、文件、信号量。                                         | ✅（主要来源）     |
| **可消耗资源**     | 运行中动态创建/销毁，如消息、信件、信号。发送/接收次序错误同样可能让进程互等。                              | ✅（如三进程都先 `receive`） |
| **可抢占资源**     | 系统或高优先级进程可强行收回，如 CPU、内存。                                                        | ❌（抢占即可打破等待） |
| **不可抢占资源**   | 只能等持有进程主动释放，如外设、刻录机、打印机。                                                      | ✅（核心问题）     |

> 结合教材实例：① 两进程互相先打开 F1、F2；② 三进程互发消息但全先 `receive`；③ 两台设备 R1、R2 的非法请求顺序，都说明**“资源属性 + 推进顺序”**是死锁根本原因。

------

## 二、死锁的四个必要条件 ⭐⭐⭐

> 对应教材：第3章 3.5.3 死锁产生的必要条件，P95～98 左右

死锁的发生必须**同时满足**以下四个条件:

### 1. 互斥条件 (Mutual Exclusion)

**定义**: 进程竞争的资源是**临界资源**（一次只能被一个进程使用）。

**说明**:

- 这是资源本身的属性
- 通常不破坏此条件
- 反而需要采用手段保证互斥

### 2. 保持并请求条件 (Hold and Wait)

**定义**: 进程已持有**至少一个资源**，同时又提出新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源**保持不放**。

**又称**: 部分分配条件

**关键点**:

- 已持有 + 又请求
- 请求被阻塞 + 保持已有资源

### 3. 不可剥夺条件 (No Preemption)

**定义**: 已分配给进程的资源，在进程使用完毕**主动释放之前**，不得强制剥夺。

**说明**:

- 资源只能由进程自己释放
- 系统不能强行收回

### 4. 环路等待条件 (Circular Wait)

**定义**: 系统的**资源分配图**中出现了环路。

**资源分配图**:

- **节点**: 进程节点（圆形）和资源节点（方形）
- **有向边**:
  - 进程→资源: 请求边
  - 资源→进程: 分配边

**⚠️ 重要辨析** (结合习题10):
> 习题10 原题：以下________________不属于死锁的必要条件。  
> 选项：A. 互斥使用资源 B. 占有并等待资源 C. 不可抢夺资源 D. 静态分配资源  
> 答案：D

**死锁的四个必要条件**:

1. ✅ 互斥使用资源
2. ✅ 占有并等待资源
3. ✅ 不可抢夺资源
4. ✅ 环路等待

**不属于必要条件**:

- ❌ 静态分配资源（这是死锁**预防**的一种策略）

**什么是静态分配资源**:

静态分配资源是指系统要求所有进程**一次性**地申请在整个进程运行过程中所需的**全部资源**，**只有当全部资源都能满足时，才分配给进程**，进程运行期间不再提出资源请求。这种方法通过破坏"保持并请求"条件来预防死锁。

------

## 三、死锁与资源分配图的关系

> 对应教材：第3章 3.5.4 资源分配图与死锁，P96 左右

### 1. 环路与死锁的关系

**命题分析**:

| 条件           | 结论                   | 正确性 |
| -------------- | ---------------------- | ------ |
| 图中**无环路** | 系统**一定不存在**死锁 | ✅ 正确 |
| 图中**有环路** | 系统**可能存在**死锁   | ✅ 正确 |
| 图中有环路     | 系统**肯定存在**死锁   | ❌ 错误 |

**结论** (习题1答案D):
> 习题1 原题：有关资源分配图中存在环路和死锁关系，正确的说法是____________。  
> 选项：A. 图中无环路则系统可能存在死锁 B. 图中无环路则系统可能存在死锁，也可能不存在死锁 C. 图中有环路则系统肯定存在死锁 D. 图中有环路则系统可能存在死锁，也可能不存在死锁  
> 答案：D

- 图中有环路 → 系统**可能**存在死锁，也**可能不**存在死锁
- 取决于资源是否有多个实例

**示例**:

```
单资源实例: 有环路 → 必定死锁
多资源实例: 有环路 → 可能死锁（也可能不死锁）
```

------

## 四、死锁的解决策略

> 对应教材：第3章 3.6 死锁的处理策略，P97～105 左右

### 策略对比总结

| 策略               | 时机       | 方法                 | 资源利用率 | 代表算法           |
| ------------------ | ---------- | -------------------- | ---------- | ------------------ |
| **死锁预防**       | 死锁发生前 | 破坏四个必要条件之一 | ⬇️ 低       | 静态分配、有序分配 |
| **死锁避免**       | 死锁发生前 | 动态检查安全性       | ➡️ 中等     | 银行家算法         |
| **死锁检测与解除** | 死锁发生后 | 检测并强制解除       | ⬆️ 高       | 资源分配图化简     |

------

## 五、死锁预防 (Deadlock Prevention)

> 对应教材：第3章 3.6.1 死锁预防，P97～98

### 核心思想

通过破坏死锁的**四个必要条件之一**，使得死锁的必要条件永远不会成立，从而防止死锁产生。

**注意**: 互斥条件一般不破坏（反而需要保证），所以主要讨论破坏其他三个条件。

### 1. 破坏"保持并请求"条件 → 静态资源分配法

**方法**:

- 系统要求所有进程**一次性**地申请在整个进程运行过程中所需的**全部资源**
- 只有当全部资源都能满足时，才分配给进程
- 进程运行期间不再提出资源请求

**伪代码**:

```
进程开始前:
    申请(资源A, 资源B, 资源C, ... 所有需要的资源);
    if (所有资源都可用)
        全部分配;
        运行进程;
    else
        等待;
```

**优点**:

- ✅ 简单且安全
- ✅ 彻底防止死锁

**缺点**:

- ❌ 进程难以一次性提出全部资源要求
- ❌ **资源利用率低**: 即使某些资源只在最后阶段才使用，也必须一开始就分配并独占
- ❌ **系统并发度降低**: 能够开始运行的进程数减少
- ❌ 可能导致**饥饿**: 资源需求多的进程可能长期得不到全部资源

**适用场景**: 资源需求明确且较少的简单系统

### 2. 破坏"不可剥夺"条件 → 资源剥夺法

**方法**:

- 进程可以动态申请资源
- 当进程请求新资源不能立即满足时:
  - **必须释放**它已占有的所有资源
  - 待以后需要时再重新申请

**什么叫动态申请资源**:

所谓**动态申请资源**，是指进程在运行过程中**按需、分阶段**提出资源请求：开始运行时可以只申请一部分资源，后续在执行到需要某些资源的代码段时，再向系统继续申请，而不是像静态分配那样一次性申请全部资源。

**过程**:

```
进程运行中:
    申请新资源;
    if (资源不可用)
        释放已占有的所有资源;
        进入等待队列;
    稍后再次申请(所有需要的资源);
```

**优点**:

- ✅ 提高资源利用率（减少长时间独占）
- ✅ 动态分配，灵活性好

**缺点**:

- ❌ **代价大**: 进程放弃已用但尚未用完的资源，可能损失大量工作
- ❌ **复杂性**: 动态分配机制复杂，系统开销大
- ❌ 进程可能**反复申请、撤销**资源，降低效率
- ❌ 只适用于**状态易保存和恢复**的资源（如CPU、内存），不适用于打印机等

**适用场景**: 资源状态易保存的系统

### 3. 破坏"环路等待"条件 → 有序资源分配法

**方法**:

- 给系统中所有资源类型编号: R₁, R₂, ..., Rₘ
- 规定进程**必须按资源编号递增的顺序**申请资源
- 已持有较大编号资源的进程不能申请较小编号的资源

**示例**:

```
资源编号: 磁带机=1, 打印机=2, 磁盘=3

合法申请顺序:
    先申请磁带机(1) → 再申请打印机(2) → 再申请磁盘(3) ✅

非法申请顺序:
    先申请磁盘(3) → 再申请磁带机(1) ❌
```

**原理**:

- 按序申请不可能形成环路
- 如果P₁持有R₁请求R₂，P₂持有R₂，那么P₂只能请求编号>2的资源，不能请求R₁

**优点**:

- ✅ 实现相对简单
- ✅ 提高资源利用率（相比静态分配）
- ✅ 系统吞吐量较好

**缺点**:

- ❌ **限制编程自由**: 可能与实际使用顺序不符
- ❌ **资源利用率下降**: 必须按序申请，即使后面的资源先用也要先申请前面的
- ❌ **不便扩展**: 编号必须相对稳定，增加新设备不方便
- ❌ 难以照顾所有用户的编程习惯

**适用场景**: 资源类型固定、使用模式规律的系统

### 4. 死锁预防方法的总体评价

**共同问题**:

- 所有预防方法都**违背了进程使用资源的自然规律**（动态执行、按需申请）
- 强加限制条件，导致**资源利用率下降**
- 可能降低**系统吞吐量**和**并发度**

**习题对应** (习题2, 4, 7):

- **按序分配策略** → 防止死锁（习题2答案A）
- **静态分配策略** → 防止死锁（习题7答案C）
- **银行家算法** → 避免死锁（**不属于**预防，习题4答案D）
> 习题2 原题：对资源采用按序分配策略能达到____________的目的。  
> 选项：A. 防止死锁 B. 避免死锁 C. 检测死锁 D. 解除死锁  
> 答案：A  
> 习题4 原题：在下列解决死锁的方法中，不属于死锁预防策略的是____________。  
> 选项：A. 资源的有序分配法 B. 资源的静态分配法 C. 分配的资源可剥夺法 D. 银行家算法  
> 答案：D  
> 习题7 原题：采用____________的手段可以防止系统出现死锁。  
> 选项：A. PV操作管理临界资源 B. 限制进程互斥使用临界资源 C. 资源静态分配策略 D. 定时运行死锁检测程序  
> 答案：C

------

## 六、死锁避免 (Deadlock Avoidance) ⭐⭐⭐

> 对应教材：第3章 3.6.2 死锁避免，P98～102

### 核心思想

**定义**: 在系统运行过程中，对进程发出的每一次资源申请进行**动态评估**，并根据评估结果决定是否分配资源:

- 若分配后系统**可能**发生死锁 → 不予分配
- 若分配后系统**安全** → 予以分配

**关键特点**:

- ✅ 允许进程**动态**地按需申请资源（符合资源使用规律）
- ✅ 在分配前**预先计算**安全性
- ✅ 资源利用率高于预防策略

### 1. 安全状态与不安全状态

#### (1) 安全状态的定义

**安全状态**: 系统能按**某种进程顺序** {P₁, P₂, ..., Pₙ} 来为每个进程Pᵢ分配其所需资源，直至**最大需求**，使每个进程都可**顺序完成**。

**安全序列**: 如果存在这样的序列，则称该序列为**安全序列**。

**安全序列的特点**:

- 对于每个进程Pᵢ，它所需的资源 ≤ 当前可用资源 + 所有Pⱼ(j<i)占有的资源
- 即: 每个进程都能等到前面的进程释放资源后获得所需资源并完成

#### (2) 安全状态示例

**场景**: 3个进程P₁、P₂、P₃，共12台磁带机

| 进程     | 最大需求 | 已分配 | 还需要 |
| -------- | -------- | ------ | ------ |
| P₁       | 10       | 5      | 5      |
| P₂       | 4        | 2      | 2      |
| P₃       | 9        | 2      | 7      |
| **可用** | -        | -      | **3**  |

**分析**:

1. P₂需要2，可用3 → P₂可以完成，释放2，可用变为3+2=5
2. P₁需要5，可用5 → P₁可以完成，释放5，可用变为5+5=10
3. P₃需要7，可用10 → P₃可以完成

**结论**: 存在安全序列 <P₂, P₁, P₃>，系统处于**安全状态**

#### (3) 不安全状态的定义

**不安全状态**: **不存在**任何一个安全序列。

**⚠️ 重要关系**:

```
安全状态 → 一定不会死锁
不安全状态 → 可能死锁（但不一定死锁）
死锁状态 → 一定是不安全状态
```

**示意图**:

```
┌─────────────────────────────┐
│     所有状态空间              │
│  ┌──────────────────────┐   │
│  │   不安全状态           │   │
│  │  ┌──────────────┐    │   │
│  │  │  死锁状态     │    │   │
│  │  └──────────────┘    │   │
│  └──────────────────────┘   │
│  ┌──────────────────────┐   │
│  │   安全状态            │   │
│  └──────────────────────┘   │
└─────────────────────────────┘
```

### 2. 银行家算法 ⭐⭐⭐ (必考大题)

银行家算法是最具代表性的**死锁避免**算法。

**类比**: 银行家不会将超过自己现有资金的钱借出去，以保证能满足客户的需求。

#### (1) 数据结构

**① Available - 可用资源向量**

```
Available[j] = K
表示系统中Rⱼ类资源当前可用K个
```

**示例**: Available = [3, 3, 2]

- 表示3类资源，可用数分别为3个、3个、2个

**② Max - 最大需求矩阵** (n×m)

```
Max[i, j] = K
表示进程Pᵢ对Rⱼ类资源的最大需求为K个
```

**③ Allocation - 分配矩阵** (n×m)

```
Allocation[i, j] = K
表示进程Pᵢ当前已分配Rⱼ类资源K个
```

**④ Need - 需求矩阵** (n×m)

```
Need[i, j] = K
表示进程Pᵢ还需要Rⱼ类资源K个

关系: Need[i, j] = Max[i, j] - Allocation[i, j]
```

**完整示例**:

假设5个进程P₀~P₄，3类资源A、B、C，资源总量[10, 5, 7]

|      | Max(A,B,C) | Allocation(A,B,C) | Need(A,B,C) |
| ---- | ---------- | ----------------- | ----------- |
| P₀   | 7, 5, 3    | 0, 1, 0           | 7, 4, 3     |
| P₁   | 3, 2, 2    | 2, 0, 0           | 1, 2, 2     |
| P₂   | 9, 0, 2    | 3, 0, 2           | 6, 0, 0     |
| P₃   | 2, 2, 2    | 2, 1, 1           | 0, 1, 1     |
| P₄   | 4, 3, 3    | 0, 0, 2           | 4, 3, 1     |

```
Available = [10,5,7] - [7,2,5] = [3, 3, 2]
```

#### (2) 银行家算法流程

当进程Pᵢ发出资源请求Request_i时，系统按以下步骤检查:

**步骤1: 合法性检查**

```
if (Request_i[j] ≤ Need[i, j]) 对所有j
    转步骤2
else
    拒绝请求（出错，超过最大需求）
```

**步骤2: 能力检查**

```
if (Request_i[j] ≤ Available[j]) 对所有j
    转步骤3
else
    Pᵢ等待（系统暂时无足够资源）
```

**步骤3: 试探性分配**

```
Available[j] = Available[j] - Request_i[j]
Allocation[i, j] = Allocation[i, j] + Request_i[j]
Need[i, j] = Need[i, j] - Request_i[j]
```

**步骤4: 安全性检查**

```
执行安全性算法
if (系统处于安全状态)
    正式分配（保留步骤3的结果）
else
    拒绝请求，恢复到步骤3之前的状态
    Pᵢ等待
```

#### (3) 安全性算法 ⭐⭐⭐

**目的**: 检查当前状态是否安全（是否存在安全序列）

**步骤1: 初始化工作变量**

```
Work = Available  // 当前可用资源
Finish[i] = false  // 所有进程，标记是否能完成
```

**步骤2: 查找可完成的进程**

```
查找同时满足以下条件的进程Pᵢ:
    ① Finish[i] = false
    ② Need[i, j] ≤ Work[j] (对所有j)

if (找到)
    转步骤3
else
    转步骤4
```

**步骤3: 模拟进程完成并释放资源**

```
Work[j] = Work[j] + Allocation[i, j]  // 回收Pᵢ的资源
Finish[i] = true
转步骤2  // 继续查找下一个进程
```

**步骤4: 判断结果**

```
if (所有Finish[i] = true)
    系统处于安全状态
    安全序列 = 按步骤3执行的进程顺序
else
    系统处于不安全状态
```

#### (4) 银行家算法计算示例 ⭐⭐⭐

**初始状态**: 如上表所示，Available = [3, 3, 2]

**问题**: 判断当前状态是否安全？

**安全性算法执行**:

| 步骤 | 选择进程 | 判断依据                     | Work                     | Finish      |
| ---- | -------- | ---------------------------- | ------------------------ | ----------- |
| 初始 | -        | -                            | [3,3,2]                  | [F,F,F,F,F] |
| 1    | P₁       | Need₁[1,2,2] ≤ Work[3,3,2] ✅ | [3,3,2]+[2,0,0]=[5,3,2]  | [F,T,F,F,F] |
| 2    | P₃       | Need₃[0,1,1] ≤ Work[5,3,2] ✅ | [5,3,2]+[2,1,1]=[7,4,3]  | [F,T,F,T,F] |
| 3    | P₄       | Need₄[4,3,1] ≤ Work[7,4,3] ✅ | [7,4,3]+[0,0,2]=[7,4,5]  | [F,T,F,T,T] |
| 4    | P₀       | Need₀[7,4,3] ≤ Work[7,4,5] ✅ | [7,4,5]+[0,1,0]=[7,5,5]  | [T,T,F,T,T] |
| 5    | P₂       | Need₂[6,0,0] ≤ Work[7,5,5] ✅ | [7,5,5]+[3,0,2]=[10,5,7] | [T,T,T,T,T] |

**结论**:

- 所有Finish = true ✅
- 安全序列: <P₁, P₃, P₄, P₀, P₂>
- 系统处于**安全状态**

------

**示例2: P₁请求资源**

P₁发出请求: Request₁ = [1, 0, 2]

**步骤1: 合法性检查**

```
Request₁[1,0,2] ≤ Need₁[1,2,2] ✅
```

**步骤2: 能力检查**

```
Request₁[1,0,2] ≤ Available[3,3,2] ✅
```

**步骤3: 试探分配**

```
Available = [3,3,2] - [1,0,2] = [2,3,0]
Allocation₁ = [2,0,0] + [1,0,2] = [3,0,2]
Need₁ = [1,2,2] - [1,0,2] = [0,2,0]
```

**步骤4: 安全性检查**

| 步骤 | 选择 | Work                      | Finish      |
| ---- | ---- | ------------------------- | ----------- |
| 初始 | -    | [2,3,0]                   | [F,F,F,F,F] |
| 1    | P₁   | [2,3,0]+[3,0,2]=[5,3,2]   | [F,T,F,F,F] |
| 2    | P₃   | [5,3,2]+[2,1,1]=[7,4,3]   | [F,T,F,T,F] |
| 3    | P₄   | [7,4,3]+[0,0,2]=[7,4,5]   | [F,T,F,T,T] |
| 4    | P₂   | [7,4,5]+[3,0,2]=[10,4,7]  | [F,T,T,T,T] |
| 5    | P₀   | [10,4,7]+[0,1,0]=[10,5,7] | [T,T,T,T,T] |

**结论**:

- 存在安全序列 <P₁, P₃, P₄, P₂, P₀>
- 系统安全 → **同意分配**

------

**示例3: P₄请求资源**

P₄发出请求: Request₄ = [3, 3, 0]

**步骤1**: Request₄[3,3,0] ≤ Need₄[4,3,1] ✅

**步骤2**: Request₄[3,3,0] ≤ Available[2,3,0] ❌

**结论**: **OS没有能力满足，P₄等待**

------

**示例4: P₀请求资源**

P₀发出请求: Request₀ = [0, 2, 0]

**步骤1**: Request₀[0,2,0] ≤ Need₀[7,4,3] ✅

**步骤2**: Request₀[0,2,0] ≤ Available[2,3,0] ✅

**步骤3: 试探分配**

```
Available = [2,3,0] - [0,2,0] = [2,1,0]
Allocation₀ = [0,1,0] + [0,2,0] = [0,3,0]
Need₀ = [7,4,3] - [0,2,0] = [7,2,3]
```

**步骤4: 安全性检查**

尝试查找安全序列:

- Work = [2,1,0]
- P₁需要[0,2,0]，Work不足 ❌
- P₃需要[0,1,1]，Work不足 ❌
- P₄需要[4,3,1]，Work不足 ❌
- P₂需要[6,0,0]，Work不足 ❌
- P₀需要[7,2,3]，Work不足 ❌

**找不到任何可完成的进程** → 不安全状态

**结论**:

- 系统进入不安全状态
- **拒绝分配**，恢复原状态

### 3. 死锁避免的特点

**优点**:

- ✅ 符合资源使用规律（动态申请）
- ✅ 资源利用率高于预防策略
- ✅ 不会产生死锁（保证安全）

**缺点**:

- ❌ 需要事先声明最大资源需求
- ❌ 进程数固定
- ❌ 资源数固定
- ❌ 每次分配都要执行安全性算法，系统开销大

**适用场景**: 资源和进程相对固定的系统

------

## 七、死锁检测与解除

> 对应教材：第3章 3.6.3 死锁检测与解除，P103～105

### 1. 死锁定理（充分条件）

**死锁定理**: 当系统的资源分配图是**不可完全简化**时，系统中发生了死锁。

**可完全简化**: 通过简化方法，最终能够将资源分配图简化，使所有节点都变成孤立节点（所有边都消去）。

### 2. 资源分配图的简化方法

**重复以下过程**:

**步骤1**:

- 从资源分配图中选择一个**非孤立**且**不阻塞**的进程
- 判断其请求边是否可以满足
- 如果可以满足，将请求边改为分配边

**步骤2**:

- 如果一个进程所有边都是分配边
- 消去其所有分配边（模拟进程完成并释放资源）

**判断**:

- 如果最终所有节点都成为孤立节点 → 可完全简化 → **无死锁**
- 如果存在无法简化的节点 → 不可完全简化 → **有死锁**

### 3. 死锁解除方法

**方法1: 资源剥夺法**

- 挂起某些死锁进程
- 剥夺其资源分配给其他进程
- 缺点: 可能造成工作损失

**方法2: 撤销进程法** (习题17答案B)

- 撤销一个或多个死锁进程
- 释放其占有的资源
- 选择策略:
  - 撤销代价最小的进程
  - 撤销优先级最低的进程
> 习题17 原题：采用资源剥夺法可以解除死锁，还可以采用__________方法解除死锁。  
> 选项：A. 执行并行操作 B. 撤消进程 C. 拒绝分配新资源 D. 修改信号量  
> 答案：B

**方法3: 进程回退法**

- 让一个或多个死锁进程回退到足以避免死锁的地步
- 需要系统保存进程的检查点

### 4. 检测与解除的特点

**优点**:

- ✅ 资源利用率最高（无预先限制）
- ✅ 系统吞吐量大

**缺点**:

- ❌ 检测算法开销大
- ❌ 解除代价大（工作丢失）
- ❌ 检测周期难以确定

**检测周期的影响**:

- 周期太短 → 开销大
- 周期太长 → 死锁持续时间长，影响扩大

------

## 八、死锁相关的易错点总结

### 1. 死锁与进程状态

**错误认识**:

- ❌ 多个等待态进程同时存在就会死锁
- ❌ 竞争CPU会导致死锁

**正确理解**:

- ✅ 死锁针对的是**竞争独占型资源**（习题9答案D）
- ✅ 死锁进程处于**阻塞状态**，等待资源而非CPU
- ✅ 共享型设备不会导致死锁（习题13答案C要求循环等待）
> 习题9 原题：“死锁”问题的讨论是针对________的。  
> 选项：A. 某个进程申请系统中不存在的资源 B. 某个进程申请资源数超过了系统拥有的最大资源数 C. 硬件故障 D. 多个并发进程竞争独占型资源  
> 答案：D  
> 习题13 原题：产生系统死锁的原因可能是由于____________。  
> 选项：A. 进程释放资源 B. 一个进程进入死循环 C. 多个进程竞争资源出现了循环等待 D. 多个进程竞争共享型设备  
> 答案：C

### 2. PV操作与死锁

**命题分析** (习题6, 15):

- ❌ "V操作可能引起死锁" - 错误
- ❌ "P操作不会引起死锁" - 错误
- ❌ "PV操作使用得当不会引起死锁" - 不准确_这个说法不准确，即使使用得当，如果资源分配策略有问题，仍可能死锁
> 习题6 原题：下列有关PV操作和死锁的叙述中，正确的是____________。  
> 选项：A. V操作可能引起死锁 B. P操作不会引起死锁 C. 使用PV操作不会引起死锁 D. 以上说法均不正确  
> 答案：D  
> 习题15 原题：有关产生死锁的论述中，____________是正确的。  
> 选项：A. “系统中仅有一个进程进入了死锁状态” B. “多个进程由于竞争CPU而进入死锁” C. “多个进程由于竞争互斥使用的资源又互不相让而进入死锁” D. “由于进程调用V操作而造成死锁”  
> 答案：C

**正确理解**:

- ✅ PV操作使用不当**可能**引起死锁
- ✅ P操作和V操作都**可能**引起死锁（取决于使用方式）

### 3. 最少资源数问题 ⭐⭐⭐

**问题模型** (习题8):

- n个并发进程，每个进程最多需要m个某类资源
- 问: 该类资源最少多少个才能不发生死锁？

**公式**:

```
最少资源数 = n × (m - 1) + 1
```

**解释**:

- 最坏情况: 每个进程都已获得(m-1)个资源
- 此时总共分配了 n×(m-1) 个资源
- 再多分配1个给任何进程，该进程就能完成并释放资源
- 避免了死锁

**习题8**: 4个进程，每个需要3个资源

```
最少资源数 = 4 × (3-1) + 1 = 9
答案: A
```
> 习题8 原题：系统中有4个并发进程，都需要某类资源3个。试问该类资源最少为__________个时，不会因竞争该资源而发生死锁。  
> 选项：A.9 B.10 C.11 D.12  
> 答案：A

------

## 九、死锁知识点对照表

| 知识点          | 对应习题   | 关键结论                   |
| --------------- | ---------- | -------------------------- |
| 环路与死锁关系  | 1          | 有环路→可能死锁            |
| 按序分配→预防   | 2          | 破坏环路条件               |
| 银行家算法→避免 | 3, 4       | 不属于预防                 |
| 静态分配→预防   | 7, 10      | 破坏保持并请求，非必要条件 |
| 最少资源数      | 8          | n×(m-1)+1                  |
| 死锁针对对象    | 9          | 独占型资源                 |
| 死锁原因        | 11, 12, 13 | 资源竞争+推进顺序          |
| PV操作与死锁    | 6, 15      | 使用不当可能死锁           |
| 解除死锁方法    | 17         | 撤销进程、剥夺资源         |

------

## 十、死锁检测与解除算法补充（教材细节）

### 1. 资源分配图检测伪代码

```
Work = Available
Finish[i] = (Allocation[i] == 0 ? true : false)

repeat
    找满足 Finish[i] == false 且 Request_i ≤ Work 的进程
    if 找到:
        Work = Work + Allocation[i]   // 假设其完成并释放资源
        Finish[i] = true
    else:
        break
until false

if 所有 Finish[i] == true → 可完全简化 → 无死锁
else → 图不可完全简化 → 系统发生死锁
```

这个流程正是教材“死锁定理”的算法化表达：能完全简化的图对应安全状态，反之说明等待环难以打破。

### 2. 解除策略的选择依据

解除死锁常用“资源剥夺 / 终止进程 / 回退进程”三类手段，教材建议根据以下指标选择代价最小的进程：

- **进程优先级与业务重要性**（实时任务尽量不撤销）；
- **已经运行的时间与完成度**（越接近完成越不应撤销）；
- **占用资源量**（释放收益越大的进程优先考虑）；
- **易恢复性**（有检查点、易回滚的进程更适合回退）；
- **系统整体吞吐的影响**（避免一次撤销就导致大量重算）。

据此可以实现从死锁状态向外扩展的“最小代价路径”：每次挑选损失最小的进程终止或剥夺，反复执行直至检测算法判定所有 `Finish[i]=true`。

------

# 配套习题

## 一、选择题（测试最少资源数计算）

### 题目1

系统中有5个并发进程，都需要某类资源4个。试问该类资源最少为__________个时，不会因竞争该资源而发生死锁。

A. 16
B. 17
C. 18
D. 20

**正确答案: A**

**解析**:

```
公式: 最少资源数 = n × (m-1) + 1
     = 5 × (4-1) + 1
     = 5 × 3 + 1
     = 16
```

------

### 题目2

某系统中有6个进程P₁~P₆，共享某类资源，每个进程最多需要该类资源5个。为了保证系统不会发生死锁，系统至少应该配置该类资源__________个。

A. 25
B. 26
C. 30
D. 31

**正确答案: B**

**解析**:

```
公式: 最少资源数 = n × (m-1) + 1
     = 6 × (5-1) + 1
     = 6 × 4 + 1
     = 25

但题目问"至少配置"，所以答案是26（≥25的最小整数）
实际上25就够了，如果选项中有25选25，
这里最接近的是26。
```

**更正**: 正确答案应该是**A. 25**

------

## 二、银行家算法应用大题

### 题目3

某系统中有5个进程P₀、P₁、P₂、P₃、P₄和3类资源A、B、C，各类资源的数量分别为10、6、8。在T₀时刻的资源分配情况如下表所示:

| 进程 | Max(A,B,C) | Allocation(A,B,C) |
| ---- | ---------- | ----------------- |
| P₀   | 8, 5, 4    | 2, 1, 2           |
| P₁   | 5, 3, 3    | 3, 1, 0           |
| P₂   | 4, 4, 3    | 1, 2, 1           |
| P₃   | 6, 4, 4    | 1, 1, 2           |
| P₄   | 3, 3, 3    | 1, 0, 1           |

**要求**:

**(1)** 计算Need矩阵和Available向量。

**(2)** 判断T₀时刻系统是否处于安全状态？如果安全，请给出一个安全序列。

**(3)** 在T₀时刻，若进程P₂发出资源请求Request₂ = (1, 1, 0)，系统能否立即分配？请说明理由。

**(4)** 在T₀时刻，若进程P₀发出资源请求Request₀ = (0, 2, 0)，系统能否立即分配？请说明理由。

------

### 参考答案

**(1) 计算Need矩阵和Available向量**

**Need矩阵** (Need = Max - Allocation):

| 进程 | Need(A,B,C) |
| ---- | ----------- |
| P₀   | 6, 4, 2     |
| P₁   | 2, 2, 3     |
| P₂   | 3, 2, 2     |
| P₃   | 5, 3, 2     |
| P₄   | 2, 3, 2     |

**Available向量**:

```
Total = (10, 6, 8)
Allocated = (2+3+1+1+1, 1+1+2+1+0, 2+0+1+2+1) = (8, 5, 6)
Available = Total - Allocated = (10-8, 6-5, 8-6) = (2, 1, 2)
```

------

**(2) 判断T₀时刻系统是否安全**

**安全性算法执行**:

| 步骤 | 选择进程 | 判断                         | Work    | Finish      |
| ---- | -------- | ---------------------------- | ------- | ----------- |
| 初始 | -        | -                            | (2,1,2) | [F,F,F,F,F] |
| 1    | P₄       | Need₄(2,3,2) vs Work(2,1,2)❌ | -       | -           |
| 1    | P₁       | Need₁(2,2,3) vs Work(2,1,2)❌ | -       | -           |
| 1    | P₂       | Need₂(3,2,2) vs Work(2,1,2)❌ | -       | -           |

**重新分析**: 实际上P₄的Need是(2,3,2)，Work是(2,1,2)，B不够。

让我重新检查各进程:

- P₀需要(6,4,2) > (2,1,2) ❌
- P₁需要(2,2,3) > (2,1,2) ❌ (C不够)
- P₂需要(3,2,2) > (2,1,2) ❌ (A不够)
- P₃需要(5,3,2) > (2,1,2) ❌
- P₄需要(2,3,2) > (2,1,2) ❌ (B不够)

**无法找到任何可完成的进程** → **系统处于不安全状态**

------

**(3) P₂请求Request₂ = (1,1,0)**

**步骤1**: Request₂(1,1,0) ≤ Need₂(3,2,2) ✅

**步骤2**: Request₂(1,1,0) ≤ Available(2,1,2) ✅

**步骤3**: 试探分配

```
Available = (2,1,2) - (1,1,0) = (1,0,2)
Allocation₂ = (1,2,1) + (1,1,0) = (2,3,1)
Need₂ = (3,2,2) - (1,1,0) = (2,1,2)
```

**步骤4**: 安全性检查

- Work = (1,0,2)
- 无法找到任何可完成的进程

**结论**: 分配后系统不安全 → **拒绝分配**

------

**(4) P₀请求Request₀ = (0,2,0)**

**步骤1**: Request₀(0,2,0) ≤ Need₀(6,4,2) ✅

**步骤2**: Request₀(0,2,0) ≤ Available(2,1,2) ❌ (B不够)

**结论**: **系统无能力满足，P₀等待**

------

**标准答案解析提示**: 这道题的初始状态已经是不安全的，这体现了系统可能在不安全状态运行但未必死锁。实际考试中，通常初始状态会是安全的。
# 操作系统进程管理复习笔记

## 一、进程核心概念

> 对应教材：第2章 2.2.1～2.2.2，P44～46（纸质书页码）

### 1. 进程的定义

**进程**是程序关于某个**数据集合**在**处理机**上的**一次执行过程**。

**进程的两个核心属性**:

- 进程是操作系统进行**资源分配**的基本单位
- 进程是操作系统进行**处理机调度**的基本单位

**进程与程序的本质区别**:

| 比较方面      | 程序                   | 进程                   |
| ------------- | ---------------------- | ---------------------- |
| **静态/动态** | 静态的有序代码集合     | 动态的执行过程         |
| **生存周期**  | 永久性                 | 有生存周期             |
| **组成**      | 指令                   | 程序+数据+PCB          |
| **对应关系**  | 一个程序可对应多个进程 | 一个进程可包含多个程序 |

### 2. 进程的特征

- **结构性**: 由程序+数据+PCB组成进程实体
- **动态性**: 由创建而产生，由调度而执行，由撤销而消亡
- **并发性**: 多个进程同时存于内存中，一起向前推进
- **独立性**: 独立获得资源和独立调度的基本单位
- **异步性**: 各进程以各自独立、不可预知的速度向前推进

### 3. 进程的组成（进程实体）

进程由三部分组成:

#### (1) 程序段

- 描述进程所要完成的功能
- 执行时不可修改的部分

#### (2) 数据集合

- 程序执行时所需要的数据和工作区
- 为进程专用，可修改

#### (3) 进程控制块 (PCB - Process Control Block)

**PCB是进程存在的唯一标志**，包含以下信息:

**① 进程描述信息**:

- **进程标识符 (PID)**: 唯一标识一个进程的整数
- **进程名**: 基于可执行文件名的外部标识

**② 进程控制信息**:

- **当前状态**: 进程当前所处状态
- **优先级**: 进程处理的缓急程度
- **程序和数据的地址**: 程序和数据所在的内存或外存地址
- **队列指针**: 处于同状态的进程链接指针

**③ 资源占用信息**:

- 进程执行时除CPU外的资源需求、分配和控制信息

**④ CPU现场保护结构**:

- 通用寄存器、PC指令计数器、PSW程序状态字、用户栈指针等
- 使进程被中断后能从断点处继续运行

------

## 二、进程状态及转换

> 对应教材：第2章 2.2.2～2.2.3，P45～50

### 1. 进程的三种基本状态

**运行态 (Running)**:

- 进程在处理机上运行

**就绪态 (Ready)**:

- 获得了**除处理机外**的一切所需资源
- 一旦得到处理机即可运行

**阻塞态 (Blocked/Waiting)**:

- 正在等待某一事件发生（如I/O完成）
- **即使把处理机分配给进程也无法运行**

### 2. 状态转换图

```
        ┌──────────┐
        │   就绪   │
        └──────────┘
           ↑  ↓
      ④唤醒│  │①调度
           │  ↓
        ┌──────────┐
    ②时│   运行   │
   间片│          │
    完 │          │
       └──────────┘
           │  ↑
      ③I/O│  │④I/O
       请求│  │完成
           ↓  │
        ┌──────────┐
        │   阻塞   │
        └──────────┘
```

**状态转换说明**:

- ① **就绪→运行**: 调度程序选择一个新进程运行
- ② **运行→就绪**: 时间片用完或高优先级进程到达（抢占式）
- ③ **运行→阻塞**: 进程请求I/O或等待某事件
- ④ **阻塞→就绪**: I/O完成或所等待的事件发生

**注意**:

- ❌ **不存在** 阻塞→运行 的直接转换
- ❌ **不存在** 就绪→阻塞 的直接转换

### 3. 扩展状态（挂起状态）

引入挂起状态后的扩展:

- **活动就绪** ↔ **静止就绪** (通过挂起/激活操作)
- **活动阻塞** ↔ **静止阻塞** (通过挂起/激活操作)
- **静止阻塞** → **静止就绪** (等待事件发生)

------

## 三、进程控制（创建/撤销/挂起/唤醒） ⭐⭐⭐

> 对应教材：第2章 2.3 进程控制，P51～55

### 1. 进程控制原语的特点

- 由 OS 在 **内核态** 执行，必须是 **原子操作**（不可中断）
- 典型原语：`Create/Destroy`、`Block/Wakeup`、`Suspend/Resume`
- 教材第2章强调：控制原语操作对象是 **PCB**，因为 PCB 是进程存在的唯一标志

### 2. 进程创建（create）

触发场景：作业调度将作业调入内存、用户请求创建子进程、操作系统需要运行内核进程等。

**创建步骤**（教材 2.3.1）：
1. **申请空白 PCB**，分配唯一 PID，初始化管理信息（优先级、状态）
2. **分配必要资源**：如内存、打开的文件表项、I/O 缓冲区
3. **设置 CPU 现场信息**：初始 PC、PSW、栈指针等
4. **将进程就绪插入就绪队列**，等待调度

> Linux 中由 `fork()` 创建子进程，父子共享正文段和大部分资源；`execve()` 用新的可执行文件替换进程映像。

### 3. 进程终止（exit/destroy）

- 正常结束（`exit()`）、异常结束（越界、非法指令）、外部干预（`kill`）、父进程结束导致子进程终止
- **终止步骤**：① 回收资源；② 从 PCB 队列删除；③ 唤醒等待它的相关进程（如 `wait()` 阻塞的父进程）

### 4. 阻塞/唤醒 与 挂起/激活

| 操作 | 触发条件 | 状态变化 | 典型场景 |
| ---- | -------- | -------- | -------- |
| `Block()` | 请求资源失败 / P 操作不满足 | 运行 → 阻塞（等待队列） | 等待 I/O、等待信号量 |
| `Wakeup()` | 资源就绪 / V 操作成功 | 阻塞 → 就绪 | I/O 完成、被唤醒 |
| `Suspend()` | 需要释放内存 / 进程调试 / 管理员命令 | 活动态 → **静止**态 | 中级调度（置换到外存） |
| `Resume()` | 外存进程被重新调入 | 静止态 → 活动态 | 高优先级作业需要运行 |

> 注意：阻塞/唤醒不改变进程是否驻留内存；挂起/激活会改变进程是否驻留内存，是中级调度手段。

### 5. 前驱图与程序顺序执行

教材 2.1 给出“前趋图”描述程序执行顺序：节点表示基本模块，边表示**直接前驱**关系。若 `Pj` 依赖 `Pi`，可用信号量或事件标志保证 `Pi` 完成后 `Pj` 才能执行。

### 6. Linux/UNIX 进程控制系统调用速记

| 调用      | 作用                         |
| --------- | ---------------------------- |
| `fork()`  | 复制当前进程，父子共享大部分资源（写时复制） |
| `exec()`  | 在当前进程空间装入并执行新程序 |
| `exit()`  | 主动终止，返回状态给父进程 |
| `wait()`/`waitpid()` | 父进程等待子进程结束并回收残留 PCB（僵尸进程） |
| `kill()`  | 发送信号终止/控制其他进程 |

> 考研常问：**`fork` + `exec`** 的组合如何完成进程创建与程序装入；僵尸进程产生的原因（父进程未 `wait`）。

------

## 四、进程通信（IPC） ⭐⭐⭐

> 对应教材：第2章 2.4 进程通信，P55～63

教材 2.4 与 PPT 中给出多种 IPC 方式，复习时要能区分特性与适用场景。

### 1. 共享存储（Shared Memory）

- 在多个进程的地址空间中映射同一物理内存区域
- 速度最快，适合大量数据交换，但需要同步机制（信号量/自旋锁）保证互斥
- Linux 提供 System V 共享内存（`shmget/shmat`）和 `mmap`

### 2. 消息传递（Message Passing）

- **直接通信**：发送者指定接收进程 `send(P, msg)`，接收者 `receive(Q, msg)`
- **间接通信**：通过**信箱/消息队列**（mailbox）完成，发送 `send(Mailbox, msg)`，接收 `receive(Mailbox, msg)`
- 阻塞/非阻塞通信影响同步方式（阻塞 send = rendezvous）
- Linux System V 消息队列、POSIX 消息队列属该范畴

### 3. 管道（Pipe/FIFO）

- 半双工字节流，仅在父子/兄弟进程之间共享（匿名管道）
- 命名管道 FIFO 允许无亲缘关系进程通信
- 特点：自动同步、顺序读写、适合**流式**数据

### 4. 信号（Signal）与事件

- Linux `signal` / `sigaction` 用于异步通知，如 `SIGINT`、`SIGCHLD`
- RTOS 中常用事件标志（event flag），属于同步/通信组合手段

### 5. 套接字 Socket / RPC

- 适用于网络分布式通信，支持面向连接（TCP）和无连接（UDP）
- RPC/管程式通信代表更高层远程过程调用

> **考试思路**：熟悉“共享内存 + 同步”“消息传递 + 信箱”“管道半双工”“套接字跨主机”，并能举例。

------

## 五、线程（Thread）与调度实体

> 对应教材：第2章 2.5 线程的概念，P63～69

教材 2.5 强调：线程是比进程更轻量的调度基本单位。

### 1. 线程的定义与优势

- 线程（Thread）是进程内的执行流，拥有独立的 **程序计数器、寄存器集合、栈**，共享所属进程的代码段、全局数据、打开文件等资源
- 优势：上下文切换开销小、并发粒度细、利于多核利用

### 2. 进程 vs 线程

| 比较点 | 进程 | 线程 |
| ------ | ---- | ---- |
| 调度单位 | 进程 | 线程 |
| 拥有资源 | 进程拥有全部资源 | 共享进程资源 |
| 创建/销毁成本 | 高 | 低 |
| 通信方式 | 需要 IPC | 共享进程地址空间即可 |

### 3. 线程实现方式

1. **用户级线程 ULT**：线程管理在用户态完成，切换快，但无法利用多核；系统仅感知到单个进程（N:1 模型）
2. **内核级线程 KLT**：由 OS 内核调度，能充分利用多核，但创建/切换成本较高（1:1 模型，如 Linux `pthread`）
3. **混合模型（M:N）**：将 N 个用户线程映射到 M 个内核线程，兼顾灵活性（如 Solaris）

### 4. 线程控制块 TCB

包含：线程 ID、寄存器现场、栈指针、优先级、线程状态、调度/统计信息。TCB + 进程 PCB 共同描述实体。

### 5. 多线程编程考点

- `pthread_create/pthread_join` 的使用
- 线程同步仍需互斥量、条件变量等
- 进程退出 `exit` 会终止其所有线程；单个线程结束用 `pthread_exit`

------

## 六、进程同步机制 ⭐⭐⭐

> 对应教材：第4章 进程同步，P110～120

### 1. 进程间的制约关系

#### (1) 间接制约（互斥）

**定义**: 并发进程由于共享某种临界资源而必须互相等待。

**临界资源 (Critical Resource, CR)**:

- 一次只能为一个进程使用的资源
- 例如: 打印机、音频设备、共享变量

**临界区 (Critical Section, CS)**:

- 程序中涉及临界资源使用的代码片段

#### (2) 直接制约（同步）

**定义**: 功能上相关的进程在某些特殊时刻必须互相通信，并根据通信结果决定继续还是暂停。

### 2. 信号量机制（记录型信号量）

#### 信号量的定义

```c
semaphore S;
// S.value: 资源可用个数或进程等待数
// S.list:  等待队列
```

#### P操作（wait操作）- 申请资源

```c
P(S) {
    S.value = S.value - 1;
    if (S.value < 0)
        block(S.list);  // 进程阻塞，挂入等待队列
}
```

**直观含义**:

- 申请一个资源
- 若资源不足 (S.value < 0)，进程阻塞等待

#### V操作（signal操作）- 释放资源

```c
V(S) {
    S.value = S.value + 1;
    if (S.value <= 0)
        wakeup(S.list);  // 唤醒一个等待进程
}
```

**直观含义**:

- 释放一个资源
- 若有进程等待 (S.value <= 0)，唤醒一个进程

#### 信号量取值规律

- **S.value ≥ 0**: 表示可用资源数，S.list = NULL
- **S.value < 0**: |S.value| 表示等待该资源的进程个数

### 3. 用信号量实现进程互斥

**问题**: N个进程并发执行，共享一个临界资源，实现互斥访问。

**解题步骤**:

**步骤1**: 分析制约关系，确定信号量

```c
semaphore S;
S.value = 1;      // 初值为1，表示资源可用
S.list = NULL;
// S用于描述临界资源的可用个数
```

**步骤2**: 确定控制细节

- **when**: 进入临界区前，离开临界区后
- **who**: 临界资源S
- **how**: 进入前P(S)申请，离开后V(S)释放

**步骤3**: 伪代码实现

```c
Pi() {  // 第i个进程
    repeat
        ...
        P(S);           // 申请临界资源
        /* 临界区 */
        V(S);           // 释放临界资源
        ...
    until false
}
```

### 4. 用信号量实现进程同步

**问题**: 多个并发进程按照前驱图规定的顺序执行。

**前驱图**: 有向无循环图（DAG），描述进程间的执行先后顺序

- 节点: 表示进程
- 有向边: 表示前驱后继关系（Pi → Pj）

**解题步骤**:

**步骤1**: 分析制约关系

- 为每一对**直接前驱后继关系**设置一个信号量
- 信号量初值 = 0

**步骤2**: 确定控制细节

- **前驱进程**: 执行结束后，V操作通知后继
- **后继进程**: 开始执行前，P操作询问前驱是否完成

**步骤3**: 伪代码模板

```c
// 对于前驱进程
Pi() {
    ...
    执行进程代码;
    V(Sij);  // 通知后继Pj: 我完成了
    ...
}

// 对于后继进程
Pj() {
    ...
    P(Sij);  // 询问前驱Pi: 你完成了吗?
    执行进程代码;
    ...
}
```

### 5. 经典同步问题

#### (1) 生产者-消费者问题

**问题描述**:

- n个生产者，m个消费者，共享大小为N的有界缓冲区
- 生产者: 生产产品→放入缓冲区
- 消费者: 从缓冲区取产品→消费

**约束条件**:

- 缓冲区是临界资源，互斥访问
- 生产者: 缓冲区满时等待
- 消费者: 缓冲区空时等待

**信号量设置**:

```c
semaphore mutex = 1;    // 互斥访问缓冲区
semaphore empty = N;    // 空格子数量
semaphore full = 0;     // 产品数量（满格子）
```

**伪代码**:

```c
// 生产者
Producer() {
    repeat
        生产一个产品;
        P(empty);       // 有空格子吗?
        P(mutex);       // 申请缓冲区
        放入产品;
        V(mutex);       // 释放缓冲区
        V(full);        // 通知消费者: 多了一个产品
    until false
}

// 消费者
Consumer() {
    repeat
        P(full);        // 有产品吗?
        P(mutex);       // 申请缓冲区
        取出产品;
        V(mutex);       // 释放缓冲区
        V(empty);       // 通知生产者: 多了一个空格
        消费产品;
    until false
}
```

**⚠️ 重要注意**:

- P(empty)和P(full)必须在P(mutex)之前
- 否则可能死锁！

#### (2) 读者-写者问题

**问题描述**:

- 多个读者和写者共享一个数据对象
- 读者: 只读数据，可并发
- 写者: 修改数据，必须互斥

**约束条件**:

- 写者与写者: 互斥
- 写者与读者: 互斥
- 读者与读者: 可并发

**信号量设置**:

```c
semaphore w = 1;         // 控制数据对象访问权
semaphore r = 1;         // 控制对readcount的互斥访问
int readcount = 0;       // 当前正在读的读者数
```

**伪代码**:

```c
// 写者
Writer() {
    repeat
        ...
        P(w);           // 申请数据对象
        写数据;
        V(w);           // 释放数据对象
        ...
    until false
}

// 读者
Reader() {
    repeat
        ...
        P(r);
        if (readcount == 0)  // 第一个读者
            P(w);            // 制造"单向门"
        readcount++;
        V(r);
        
        读数据;
        
        P(r);
        readcount--;
        if (readcount == 0)  // 最后一个读者
            V(w);            // 释放数据对象
        V(r);
        ...
    until false
}
```

------

## 七、处理机调度 ⭐⭐⭐ (必考大题)

> 对应教材：第3章 处理机调度，P73～82

### 1. 调度的三个层次

| 调度层次     | 别名               | 频率         | 功能                     |
| ------------ | ------------------ | ------------ | ------------------------ |
| **高级调度** | 作业调度、长程调度 | 几分钟一次   | 从后备队列选作业进入内存 |
| **中级调度** | 交换调度           | 介于两者之间 | 换入换出，提高内存利用率 |
| **低级调度** | 进程调度、短程调度 | 几十毫秒一次 | 从就绪队列选进程分配CPU  |

#### 教材补充：作业状态与调度流程

- **作业四态**：提交 → 后备（在外存，等待高级调度）→ 执行（已建进程在内存）→ 完成（待资源回收）。教材强调作业调度的任务是“挑选 + 分派资源 + 建立进程”。
- **中级调度**：由换入/换出组成。换出把暂时不用的程序/数据写到交换区（教材指出采用连续分配以加快 I/O），换入则把需要的信息重新读回内存，核心目标是提高内存利用率与系统吞吐量。
- **三级调度之间的联系**：作业调度决定“哪些作业获得进程资格”，中级调度决定“哪些进程保持驻留”，低级调度决定“哪个驻留进程占用 CPU”。考试常要求画出“提交→后备→就绪→运行→阻塞→完成”的全流程。

### 2. 进程调度方式

#### (1) 非抢占方式（非剥夺）

- 进程一旦获得CPU，一直执行到完成或阻塞
- 引起调度的因素: 进程结束、阻塞、执行P操作
- 特点: 简单，开销小，但无法处理紧急任务

#### (2) 抢占方式（剥夺）

- 允许停止正在执行的进程，重新分配CPU
- 抢占原则: 优先权、最短剩余时间、时间片
- 特点: 能响应紧急任务，但开销较大

#### 教材补充：进程调度触发条件

按照《计算机操作系统（慕课版）》第3章，以下事件会立即进入调度流程：

1. 正在运行的进程自然结束；
2. 运行进程因 P 操作、I/O、缺页等原因阻塞；
3. 有新进程进入就绪队列（尤其是抢占式系统）；
4. 更高优先级的进程到达或从阻塞态被唤醒；
5. 时间片用完；
6. 从系统调用或中断返回时检测到需要重选 CPU 占用者。

记忆法：**“终、阻、新、优、片、中”**——终止、阻塞、新到、优先、时间片、中断返回。

### 3. 调度算法性能评价指标

#### 批处理系统指标

**周转时间 (Turnaround Time)**:

```
周转时间 = 完成时间 - 提交时间
       = 等待时间 + 运行时间
```

**平均周转时间**:

```
T = (T₁ + T₂ + ... + Tₙ) / n
```

**带权周转时间 (Normalized Turnaround Time)**:

```
带权周转时间 = 周转时间 / 运行时间
```

**平均带权周转时间**:

```
W = (W₁ + W₂ + ... + Wₙ) / n
```

#### 分时系统指标

- **响应时间**: 从提交请求到系统响应的时间间隔
- 响应时间 = 时间片 × 进程数

#### 实时系统指标

- **截止时间**: 任务必须开始或完成的最迟时间

#### 教材补充：调度准则分类

- **面向系统的准则**：公平性（每个进程获得合理 CPU 时间）、CPU 利用率、系统吞吐量、资源利用率（让 CPU、I/O、内存保持忙碌）。
- **面向用户的准则**：周转时间短（批处理）、响应时间快（分时）、截止时间可保障（实时）、优先权需求得到满足。

在主观题里可用“系统四项 + 用户三项”记忆，答题时指出“不同 OS 类型对权重不同”。

### 4. 调度算法详解 ⭐⭐⭐

#### (1) 先来先服务 (FCFS - First Come First Serve)

**原理**:

- 按到达队列的**先后顺序**调度
- 队列排队原则: 按到达时间排序（先到先排）

**特点**:

- ✅ 简单易实现
- ❌ 不利于短作业（带权周转时间长）
- ❌ 不利于I/O频繁型作业

**适用**: 批处理系统

**计算示例**:

```
作业  到达时间  运行时间
A     0         3
B     1         6
C     2         4

调度顺序: A → B → C
完成时间: 3,  9,  13
周转时间: 3,  8,  11
平均周转时间 = (3+8+11)/3 = 7.33
带权周转时间: 1,  1.33, 2.75
平均带权周转时间 = (1+1.33+2.75)/3 = 1.69
```

#### (2) 短作业优先 (SJF/SPF - Shortest Job First)

**原理**:

- 按**估计运行时间**从短到长调度
- 队列排队原则: 按运行时间排序（短的先排）

**特点**:

- ✅ 能获得**最短的平均带权周转时间**（最优）
- ❌ 对长作业不利，可能导致饥饿
- ❌ 运行时间难以准确估计

**适用**: 批处理系统

**计算示例**:

```
作业  到达时间  运行时间
A     0         3
B     1         6
C     2         4

调度顺序: A → C → B (到达后按运行时间排序)
完成时间: 3,  13, 7
周转时间: 3,  12, 5
平均周转时间 = (3+12+5)/3 = 6.67
带权周转时间: 1,  2,   1.25
平均带权周转时间 = (1+2+1.25)/3 = 1.42
```

#### (3) 时间片轮转 (Round Robin, RR)

**原理**:

- 所有就绪进程按**到达时间**排成队列
- 每个进程执行一个**时间片**
- 时间片用完→进程放回队尾→调度队首进程
- 队列排队原则: 按到达就绪队列的时间排序

**特点**:

- ✅ 响应时间快
- ✅ 公平性好
- ❌ 时间片太大→退化为FCFS
- ❌ 时间片太小→调度开销大

**适用**: 分时系统

**时间片大小选择**:

```
响应时间 = 时间片 × 进程数
```

- 考虑系统响应时间要求
- 考虑就绪队列进程数
- 考虑系统处理能力

> 教材补充：时间片过大 → 失去分时意义；时间片过小 → CPU 大量时间花在上下文切换。实际系统会结合“平均交互时间”“CPU 主频”来设定一个经验值，再根据运行时监控动态调整。

**计算示例**:

```
进程  到达时间  运行时间
A     0         3
B     1         6
C     2         4

时间片 = 2

时间轴分析:
0-2:   A运行(2)，剩余1
2-4:   B运行(2)，剩余4
4-6:   C运行(2)，剩余2
6-7:   A运行(1)，完成 ✓
7-9:   B运行(2)，剩余2
9-11:  C运行(2)，完成 ✓
11-13: B运行(2)，完成 ✓

完成时间: 7,  13, 11
周转时间: 7,  12, 9
平均周转时间 = (7+12+9)/3 = 9.33
```

#### (4) 优先级调度 (Priority Scheduling)

**原理**:

- 按**优先级**从高到低调度
- 队列排队原则: 按优先级排序（高优先级先排）

**分类**:

**① 静态优先级**:

- 创建时确定，运行期间不变
- 确定依据:
  - 进程类型（系统 > 用户）
  - 资源需求（执行时间短 > 长）
  - 到达时间（先到 > 后到）
- 特点: 简单，开销小，但不精确

**② 动态优先级**:

- 运行过程中根据情况动态调整
- 调整依据:
  - CPU使用时间（用得少 > 用得多）
  - 等待时间（等得久 > 等得少）
- 公式示例: `优先数 = CPU使用时间/2 + 基本优先数`
- 特点: 灵活，但开销大

**调度方式**:

**非抢占式**:

- 进程获得CPU后运行到完成或阻塞

**抢占式**:

- 出现更高优先级进程时，停止当前进程

#### (5) 高响应比优先 (HRRN - Highest Response Ratio Next)

**原理**:

- 综合考虑等待时间和运行时间
- 按**响应比**从高到低调度
- 队列排队原则: 按响应比排序（高的先排）

**响应比公式**:

```
响应比 = (等待时间 + 运行时间) / 运行时间
       = 1 + 等待时间 / 运行时间
```

**特点**:

- ✅ 等待时间相同→短作业优先
- ✅ 运行时间相同→先来先服务
- ✅ 长进程不会饥饿（等待时间长→响应比高）
- ✅ 综合了FCFS和SJF的优点

**适用**: 批处理系统

**计算示例**:

```
作业  到达时间  运行时间
A     0         3
B     1         6  
C     2         4

时刻3调度:
A已完成
B: 响应比 = (2+6)/6 = 1.33
C: 响应比 = (1+4)/4 = 1.25
→ 选B

时刻9调度:
C: 响应比 = (7+4)/4 = 2.75
→ 选C
```

#### (6) 多级反馈队列 (Multilevel Feedback Queue)

**原理**:

- 设置多个就绪队列，每个队列有不同优先级和时间片
- 优先级: P₁ > P₂ > ... > Pₙ
- 时间片: Q₁ < Q₂ < ... < Qₙ

**调度规则**:

1. 新进程→第1队列队尾，按FCFS等待
2. 执行一个时间片:
   - 完成→撤离系统
   - 未完成→转入下一级队列队尾
   - I/O未用完时间片→I/O完成后回原队列队尾
3. 仅当前i-1个队列为空时，才调度第i队列
4. **抢占**: 高优先级队列有新进程→抢占CPU

**特点**:

- ✅ 终端型用户: 一个时间片内完成，响应快
- ✅ 短批处理作业: 前几个队列完成，周转短
- ✅ 长批处理作业: 不会长时间得不到处理
- ✅ 兼顾了多种用户需求

------

## 八、调度算法对比总结

| 算法         | 排队原则       | 优点                 | 缺点                | 适用场景 |
| ------------ | -------------- | -------------------- | ------------------- | -------- |
| **FCFS**     | 到达时间       | 简单易实现           | 不利于短作业和I/O型 | 批处理   |
| **SJF**      | 运行时间       | 平均带权周转时间最短 | 长作业饥饿，难估计  | 批处理   |
| **RR**       | 到达时间(循环) | 响应快，公平         | 时间片选择困难      | 分时     |
| **优先级**   | 优先级         | 灵活，可区分重要性   | 低优先级饥饿        | 通用     |
| **HRRN**     | 响应比         | 综合FCFS和SJF优点    | 计算开销大          | 批处理   |
| **多级反馈** | 多队列+时间片  | 兼顾多种需求         | 复杂度高            | 通用     |

------

## 九、调度计算步骤总结

### 标准计算模板

**给定信息**:

- 进程名、到达时间、运行时间

**计算步骤**:

**步骤1**: 根据调度算法确定调度顺序

- FCFS: 按到达时间排序
- SJF: 按运行时间排序（到达后）
- RR: 时间轴模拟
- 优先级: 按优先级排序
- HRRN: 每次调度时计算响应比

**步骤2**: 计算完成时间

```
完成时间 = 上一个进程完成时间 + 本进程运行时间
（第一个进程: 完成时间 = 到达时间 + 运行时间）
```

**步骤3**: 计算周转时间

```
周转时间 = 完成时间 - 到达时间
```

**步骤4**: 计算带权周转时间

```
带权周转时间 = 周转时间 / 运行时间
```

**步骤5**: 计算平均值

```
平均周转时间 = Σ周转时间 / n
平均带权周转时间 = Σ带权周转时间 / n
```

------

# 配套综合应用题

## 题目1: FCFS vs SJF 对比计算

有4个作业A、B、C、D，它们的到达时间和运行时间如下表所示:

| 作业 | 到达时间 | 运行时间 |
| ---- | -------- | -------- |
| A    | 8:00     | 2.0小时  |
| B    | 8:30     | 1.0小时  |
| C    | 9:00     | 0.5小时  |
| D    | 9:30     | 0.3小时  |

**要求**:

1. 分别采用FCFS和SJF算法，写出调度顺序
2. 计算每个作业的周转时间和带权周转时间
3. 计算平均周转时间和平均带权周转时间
4. 比较两种算法的性能

------

## 题目2: 时间片轮转调度

有5个进程P1、P2、P3、P4、P5，它们的到达时间和服务时间如下:

| 进程 | 到达时间 | 服务时间 |
| ---- | -------- | -------- |
| P1   | 0        | 4        |
| P2   | 1        | 3        |
| P3   | 2        | 5        |
| P4   | 3        | 2        |
| P5   | 4        | 4        |

**要求**:

1. 采用时间片轮转算法，时间片q=2，画出进程调度的甘特图
2. 计算每个进程的周转时间和带权周转时间
3. 计算平均周转时间和平均带权周转时间
4. 如果时间片改为q=1，重新计算平均周转时间，并分析时间片大小对性能的影响

------

## 题目3: 高响应比优先调度

有3个作业J1、J2、J3同时到达系统（到达时间均为0），它们的运行时间分别为:

| 作业 | 运行时间 |
| ---- | -------- |
| J1   | 5        |
| J2   | 3        |
| J3   | 7        |

又有两个作业J4和J5分别在时刻2和时刻4到达:

| 作业 | 到达时间 | 运行时间 |
| ---- | -------- | -------- |
| J4   | 2        | 2        |
| J5   | 4        | 4        |

**要求**:

1. 采用高响应比优先调度算法（非抢占式），写出详细的调度过程
2. 在每次调度时，列出所有就绪作业的响应比计算过程
3. 计算每个作业的周转时间和带权周转时间
4. 计算平均周转时间和平均带权周转时间
5. 说明高响应比优先算法如何平衡短作业和长作业

------

## 参考答案要点

### 题目1答案要点:

**FCFS调度顺序**: A → B → C → D

| 作业 | 完成时间 | 周转时间 | 带权周转时间 |
| ---- | -------- | -------- | ------------ |
| A    | 10:00    | 2.0      | 1.0          |
| B    | 11:00    | 2.5      | 2.5          |
| C    | 11:30    | 2.5      | 5.0          |
| D    | 11:48    | 2.3      | 7.67         |

- 平均周转时间 = 2.325小时
- 平均带权周转时间 = 4.04

**SJF调度顺序**: A → D → C → B

| 作业 | 完成时间 | 周转时间 | 带权周转时间 |
| ---- | -------- | -------- | ------------ |
| A    | 10:00    | 2.0      | 1.0          |
| D    | 10:18    | 0.8      | 2.67         |
| C    | 10:48    | 1.8      | 3.6          |
| B    | 11:48    | 3.3      | 3.3          |

- 平均周转时间 = 1.975小时
- 平均带权周转时间 = 2.64

**性能对比**: SJF在两个指标上都优于FCFS

### 题目2答案要点:

**时间片q=2的调度过程**（甘特图关键时刻）:

- 0-2: P1, 2-4: P2, 4-6: P3, 6-8: P4完成+P5, 8-10: P1完成+P2, 10-12: P3, 12-14: P5, 14-16: P3完成+P5完成

**时间片大小影响**:

- 时间片越小→响应时间越短，但调度开销越大
- 时间片越大→调度开销越小，但响应时间越长

### 题目3答案要点:

**调度过程**:

- 时刻0: J2响应比最高(1.0，但运行时间最短) → 选J2
- 时刻3: 计算J1、J3、J4响应比 → 选响应比最高者
- 依此类推...

**关键点**: 高响应比 = 等待时间长或运行时间短，兼顾公平性
# 操作系统进程管理复习笔记

## 一、进程核心概念

### 1. 进程的定义

**进程**是程序关于某个**数据集合**在**处理机**上的**一次执行过程**。

**进程的两个核心属性**:

- 进程是操作系统进行**资源分配**的基本单位
- 进程是操作系统进行**处理机调度**的基本单位

**进程与程序的本质区别**:

| 比较方面      | 程序                   | 进程                   |
| ------------- | ---------------------- | ---------------------- |
| **静态/动态** | 静态的有序代码集合     | 动态的执行过程         |
| **生存周期**  | 永久性                 | 有生存周期             |
| **组成**      | 指令                   | 程序+数据+PCB          |
| **对应关系**  | 一个程序可对应多个进程 | 一个进程可包含多个程序 |

### 2. 进程的特征

- **结构性**: 由程序+数据+PCB组成进程实体
- **动态性**: 由创建而产生，由调度而执行，由撤销而消亡
- **并发性**: 多个进程同时存于内存中，一起向前推进
- **独立性**: 独立获得资源和独立调度的基本单位
- **异步性**: 各进程以各自独立、不可预知的速度向前推进

### 3. 进程的组成（进程实体）

进程由三部分组成:

#### (1) 程序段

- 描述进程所要完成的功能
- 执行时不可修改的部分

#### (2) 数据集合

- 程序执行时所需要的数据和工作区
- 为进程专用，可修改

#### (3) 进程控制块 (PCB - Process Control Block)

**PCB是进程存在的唯一标志**，包含以下信息:

**① 进程描述信息**:

- **进程标识符 (PID)**: 唯一标识一个进程的整数
- **进程名**: 基于可执行文件名的外部标识

**② 进程控制信息**:

- **当前状态**: 进程当前所处状态
- **优先级**: 进程处理的缓急程度
- **程序和数据的地址**: 程序和数据所在的内存或外存地址
- **队列指针**: 处于同状态的进程链接指针

**③ 资源占用信息**:

- 进程执行时除CPU外的资源需求、分配和控制信息

**④ CPU现场保护结构**:

- 通用寄存器、PC指令计数器、PSW程序状态字、用户栈指针等
- 使进程被中断后能从断点处继续运行

------

## 二、进程状态及转换

### 1. 进程的三种基本状态

**运行态 (Running)**:

- 进程在处理机上运行

**就绪态 (Ready)**:

- 获得了**除处理机外**的一切所需资源
- 一旦得到处理机即可运行

**阻塞态 (Blocked/Waiting)**:

- 正在等待某一事件发生（如I/O完成）
- **即使把处理机分配给进程也无法运行**

### 2. 状态转换图

```
        ┌──────────┐
        │   就绪   │
        └──────────┘
           ↑  ↓
      ④唤醒│  │①调度
           │  ↓
        ┌──────────┐
    ②时│   运行   │
   间片│          │
    完 │          │
       └──────────┘
           │  ↑
      ③I/O│  │④I/O
       请求│  │完成
           ↓  │
        ┌──────────┐
        │   阻塞   │
        └──────────┘
```

**状态转换说明**:

- ① **就绪→运行**: 调度程序选择一个新进程运行
- ② **运行→就绪**: 时间片用完或高优先级进程到达（抢占式）
- ③ **运行→阻塞**: 进程请求I/O或等待某事件
- ④ **阻塞→就绪**: I/O完成或所等待的事件发生

**注意**:

- ❌ **不存在** 阻塞→运行 的直接转换
- ❌ **不存在** 就绪→阻塞 的直接转换

### 3. 扩展状态（挂起状态）

引入挂起状态后的扩展:

- **活动就绪** ↔ **静止就绪** (通过挂起/激活操作)
- **活动阻塞** ↔ **静止阻塞** (通过挂起/激活操作)
- **静止阻塞** → **静止就绪** (等待事件发生)

------

## 三、进程同步机制 ⭐⭐⭐

### 1. 进程间的制约关系

#### (1) 间接制约（互斥）

**定义**: 并发进程由于共享某种临界资源而必须互相等待。

**临界资源 (Critical Resource, CR)**:

- 一次只能为一个进程使用的资源
- 例如: 打印机、音频设备、共享变量

**临界区 (Critical Section, CS)**:

- 程序中涉及临界资源使用的代码片段

#### (2) 直接制约（同步）

**定义**: 功能上相关的进程在某些特殊时刻必须互相通信，并根据通信结果决定继续还是暂停。

### 2. 信号量机制（记录型信号量）

#### 信号量的定义

```c
semaphore S;
// S.value: 资源可用个数或进程等待数
// S.list:  等待队列
```

#### P操作（wait操作）- 申请资源

```c
P(S) {
    S.value = S.value - 1;
    if (S.value < 0)
        block(S.list);  // 进程阻塞，挂入等待队列
}
```

**直观含义**:

- 申请一个资源
- 若资源不足 (S.value < 0)，进程阻塞等待

#### V操作（signal操作）- 释放资源

```c
V(S) {
    S.value = S.value + 1;
    if (S.value <= 0)
        wakeup(S.list);  // 唤醒一个等待进程
}
```

**直观含义**:

- 释放一个资源
- 若有进程等待 (S.value <= 0)，唤醒一个进程

#### 信号量取值规律

- **S.value ≥ 0**: 表示可用资源数，S.list = NULL
- **S.value < 0**: |S.value| 表示等待该资源的进程个数

### 3. 用信号量实现进程互斥

**问题**: N个进程并发执行，共享一个临界资源，实现互斥访问。

**解题步骤**:

**步骤1**: 分析制约关系，确定信号量

```c
semaphore S;
S.value = 1;      // 初值为1，表示资源可用
S.list = NULL;
// S用于描述临界资源的可用个数
```

**步骤2**: 确定控制细节

- **when**: 进入临界区前，离开临界区后
- **who**: 临界资源S
- **how**: 进入前P(S)申请，离开后V(S)释放

**步骤3**: 伪代码实现

```c
Pi() {  // 第i个进程
    repeat
        ...
        P(S);           // 申请临界资源
        /* 临界区 */
        V(S);           // 释放临界资源
        ...
    until false
}
```

### 4. 用信号量实现进程同步

**问题**: 多个并发进程按照前驱图规定的顺序执行。

**前驱图**: 有向无循环图（DAG），描述进程间的执行先后顺序

- 节点: 表示进程
- 有向边: 表示前驱后继关系（Pi → Pj）

**解题步骤**:

**步骤1**: 分析制约关系

- 为每一对**直接前驱后继关系**设置一个信号量
- 信号量初值 = 0

**步骤2**: 确定控制细节

- **前驱进程**: 执行结束后，V操作通知后继
- **后继进程**: 开始执行前，P操作询问前驱是否完成

**步骤3**: 伪代码模板

```c
// 对于前驱进程
Pi() {
    ...
    执行进程代码;
    V(Sij);  // 通知后继Pj: 我完成了
    ...
}

// 对于后继进程
Pj() {
    ...
    P(Sij);  // 询问前驱Pi: 你完成了吗?
    执行进程代码;
    ...
}
```

### 5. 经典同步问题

#### (1) 生产者-消费者问题

**问题描述**:

- n个生产者，m个消费者，共享大小为N的有界缓冲区
- 生产者: 生产产品→放入缓冲区
- 消费者: 从缓冲区取产品→消费

**约束条件**:

- 缓冲区是临界资源，互斥访问
- 生产者: 缓冲区满时等待
- 消费者: 缓冲区空时等待

**信号量设置**:

```c
semaphore mutex = 1;    // 互斥访问缓冲区
semaphore empty = N;    // 空格子数量
semaphore full = 0;     // 产品数量（满格子）
```

**伪代码**:

```c
// 生产者
Producer() {
    repeat
        生产一个产品;
        P(empty);       // 有空格子吗?
        P(mutex);       // 申请缓冲区
        放入产品;
        V(mutex);       // 释放缓冲区
        V(full);        // 通知消费者: 多了一个产品
    until false
}

// 消费者
Consumer() {
    repeat
        P(full);        // 有产品吗?
        P(mutex);       // 申请缓冲区
        取出产品;
        V(mutex);       // 释放缓冲区
        V(empty);       // 通知生产者: 多了一个空格
        消费产品;
    until false
}
```

**⚠️ 重要注意**:

- P(empty)和P(full)必须在P(mutex)之前
- 否则可能死锁！

#### (2) 读者-写者问题

**问题描述**:

- 多个读者和写者共享一个数据对象
- 读者: 只读数据，可并发
- 写者: 修改数据，必须互斥

**约束条件**:

- 写者与写者: 互斥
- 写者与读者: 互斥
- 读者与读者: 可并发

**信号量设置**:

```c
semaphore w = 1;         // 控制数据对象访问权
semaphore r = 1;         // 控制对readcount的互斥访问
int readcount = 0;       // 当前正在读的读者数
```

**伪代码**:

```c
// 写者
Writer() {
    repeat
        ...
        P(w);           // 申请数据对象
        写数据;
        V(w);           // 释放数据对象
        ...
    until false
}

// 读者
Reader() {
    repeat
        ...
        P(r);
        if (readcount == 0)  // 第一个读者
            P(w);            // 制造"单向门"
        readcount++;
        V(r);
        
        读数据;
        
        P(r);
        readcount--;
        if (readcount == 0)  // 最后一个读者
            V(w);            // 释放数据对象
        V(r);
        ...
    until false
}
```

------

## 四、处理机调度 ⭐⭐⭐ (必考大题)

### 1. 调度的三个层次

| 调度层次     | 别名               | 频率         | 功能                     |
| ------------ | ------------------ | ------------ | ------------------------ |
| **高级调度** | 作业调度、长程调度 | 几分钟一次   | 从后备队列选作业进入内存 |
| **中级调度** | 交换调度           | 介于两者之间 | 换入换出，提高内存利用率 |
| **低级调度** | 进程调度、短程调度 | 几十毫秒一次 | 从就绪队列选进程分配CPU  |

### 2. 进程调度方式

#### (1) 非抢占方式（非剥夺）

- 进程一旦获得CPU，一直执行到完成或阻塞
- 引起调度的因素: 进程结束、阻塞、执行P操作
- 特点: 简单，开销小，但无法处理紧急任务

#### (2) 抢占方式（剥夺）

- 允许停止正在执行的进程，重新分配CPU
- 抢占原则: 优先权、最短剩余时间、时间片
- 特点: 能响应紧急任务，但开销较大

### 3. 调度算法性能评价指标

#### 批处理系统指标

**周转时间 (Turnaround Time)**:

```
周转时间 = 完成时间 - 提交时间
       = 等待时间 + 运行时间
```

**平均周转时间**:

```
T = (T₁ + T₂ + ... + Tₙ) / n
```

**带权周转时间 (Normalized Turnaround Time)**:

```
带权周转时间 = 周转时间 / 运行时间
```

**平均带权周转时间**:

```
W = (W₁ + W₂ + ... + Wₙ) / n
```

#### 分时系统指标

- **响应时间**: 从提交请求到系统响应的时间间隔
- 响应时间 = 时间片 × 进程数

#### 实时系统指标

- **截止时间**: 任务必须开始或完成的最迟时间

### 4. 调度算法详解 ⭐⭐⭐

#### (1) 先来先服务 (FCFS - First Come First Serve)

**原理**:

- 按到达队列的**先后顺序**调度
- 队列排队原则: 按到达时间排序（先到先排）

**特点**:

- ✅ 简单易实现
- ❌ 不利于短作业（带权周转时间长）
- ❌ 不利于I/O频繁型作业

**适用**: 批处理系统

**计算示例**:

```
作业  到达时间  运行时间
A     0         3
B     1         6
C     2         4

调度顺序: A → B → C
完成时间: 3,  9,  13
周转时间: 3,  8,  11
平均周转时间 = (3+8+11)/3 = 7.33
带权周转时间: 1,  1.33, 2.75
平均带权周转时间 = (1+1.33+2.75)/3 = 1.69
```

#### (2) 短作业优先 (SJF/SPF - Shortest Job First)

**原理**:

- 按**估计运行时间**从短到长调度
- 队列排队原则: 按运行时间排序（短的先排）

**特点**:

- ✅ 能获得**最短的平均带权周转时间**（最优）
- ❌ 对长作业不利，可能导致饥饿
- ❌ 运行时间难以准确估计

**适用**: 批处理系统

**计算示例**:

```
作业  到达时间  运行时间
A     0         3
B     1         6
C     2         4

调度顺序: A → C → B (到达后按运行时间排序)
完成时间: 3,  13, 7
周转时间: 3,  12, 5
平均周转时间 = (3+12+5)/3 = 6.67
带权周转时间: 1,  2,   1.25
平均带权周转时间 = (1+2+1.25)/3 = 1.42
```

#### (3) 时间片轮转 (Round Robin, RR)

**原理**:

- 所有就绪进程按**到达时间**排成队列
- 每个进程执行一个**时间片**
- 时间片用完→进程放回队尾→调度队首进程
- 队列排队原则: 按到达就绪队列的时间排序

**特点**:

- ✅ 响应时间快
- ✅ 公平性好
- ❌ 时间片太大→退化为FCFS
- ❌ 时间片太小→调度开销大

**适用**: 分时系统

**时间片大小选择**:

```
响应时间 = 时间片 × 进程数
```

- 考虑系统响应时间要求
- 考虑就绪队列进程数
- 考虑系统处理能力

**计算示例**:

```
进程  到达时间  运行时间
A     0         3
B     1         6
C     2         4

时间片 = 2

时间轴分析:
0-2:   A运行(2)，剩余1
2-4:   B运行(2)，剩余4
4-6:   C运行(2)，剩余2
6-7:   A运行(1)，完成 ✓
7-9:   B运行(2)，剩余2
9-11:  C运行(2)，完成 ✓
11-13: B运行(2)，完成 ✓

完成时间: 7,  13, 11
周转时间: 7,  12, 9
平均周转时间 = (7+12+9)/3 = 9.33
```

#### (4) 优先级调度 (Priority Scheduling)

**原理**:

- 按**优先级**从高到低调度
- 队列排队原则: 按优先级排序（高优先级先排）

**分类**:

**① 静态优先级**:

- 创建时确定，运行期间不变
- 确定依据:
  - 进程类型（系统 > 用户）
  - 资源需求（执行时间短 > 长）
  - 到达时间（先到 > 后到）
- 特点: 简单，开销小，但不精确

**② 动态优先级**:

- 运行过程中根据情况动态调整
- 调整依据:
  - CPU使用时间（用得少 > 用得多）
  - 等待时间（等得久 > 等得少）
- 公式示例: `优先数 = CPU使用时间/2 + 基本优先数`
- 特点: 灵活，但开销大

**调度方式**:

**非抢占式**:

- 进程获得CPU后运行到完成或阻塞

**抢占式**:

- 出现更高优先级进程时，停止当前进程

#### (5) 高响应比优先 (HRRN - Highest Response Ratio Next)

**原理**:

- 综合考虑等待时间和运行时间
- 按**响应比**从高到低调度
- 队列排队原则: 按响应比排序（高的先排）

**响应比公式**:

```
响应比 = (等待时间 + 运行时间) / 运行时间
       = 1 + 等待时间 / 运行时间
```

**特点**:

- ✅ 等待时间相同→短作业优先
- ✅ 运行时间相同→先来先服务
- ✅ 长进程不会饥饿（等待时间长→响应比高）
- ✅ 综合了FCFS和SJF的优点

**适用**: 批处理系统

**计算示例**:

```
作业  到达时间  运行时间
A     0         3
B     1         6  
C     2         4

时刻3调度:
A已完成
B: 响应比 = (2+6)/6 = 1.33
C: 响应比 = (1+4)/4 = 1.25
→ 选B

时刻9调度:
C: 响应比 = (7+4)/4 = 2.75
→ 选C
```

#### (6) 多级反馈队列 (Multilevel Feedback Queue)

**原理**:

- 设置多个就绪队列，每个队列有不同优先级和时间片
- 优先级: P₁ > P₂ > ... > Pₙ
- 时间片: Q₁ < Q₂ < ... < Qₙ

**调度规则**:

1. 新进程→第1队列队尾，按FCFS等待
2. 执行一个时间片:
   - 完成→撤离系统
   - 未完成→转入下一级队列队尾
   - I/O未用完时间片→I/O完成后回原队列队尾
3. 仅当前i-1个队列为空时，才调度第i队列
4. **抢占**: 高优先级队列有新进程→抢占CPU

**特点**:

- ✅ 终端型用户: 一个时间片内完成，响应快
- ✅ 短批处理作业: 前几个队列完成，周转短
- ✅ 长批处理作业: 不会长时间得不到处理
- ✅ 兼顾了多种用户需求

------

## 五、调度算法对比总结

| 算法         | 排队原则       | 优点                 | 缺点                | 适用场景 |
| ------------ | -------------- | -------------------- | ------------------- | -------- |
| **FCFS**     | 到达时间       | 简单易实现           | 不利于短作业和I/O型 | 批处理   |
| **SJF**      | 运行时间       | 平均带权周转时间最短 | 长作业饥饿，难估计  | 批处理   |
| **RR**       | 到达时间(循环) | 响应快，公平         | 时间片选择困难      | 分时     |
| **优先级**   | 优先级         | 灵活，可区分重要性   | 低优先级饥饿        | 通用     |
| **HRRN**     | 响应比         | 综合FCFS和SJF优点    | 计算开销大          | 批处理   |
| **多级反馈** | 多队列+时间片  | 兼顾多种需求         | 复杂度高            | 通用     |

------

## 六、调度计算步骤总结

### 标准计算模板

**给定信息**:

- 进程名、到达时间、运行时间

**计算步骤**:

**步骤1**: 根据调度算法确定调度顺序

- FCFS: 按到达时间排序
- SJF: 按运行时间排序（到达后）
- RR: 时间轴模拟
- 优先级: 按优先级排序
- HRRN: 每次调度时计算响应比

**步骤2**: 计算完成时间

```
完成时间 = 上一个进程完成时间 + 本进程运行时间
（第一个进程: 完成时间 = 到达时间 + 运行时间）
```

**步骤3**: 计算周转时间

```
周转时间 = 完成时间 - 到达时间
```

**步骤4**: 计算带权周转时间

```
带权周转时间 = 周转时间 / 运行时间
```

**步骤5**: 计算平均值

```
平均周转时间 = Σ周转时间 / n
平均带权周转时间 = Σ带权周转时间 / n
```

------

# 配套综合应用题

## 题目1: FCFS vs SJF 对比计算

有4个作业A、B、C、D，它们的到达时间和运行时间如下表所示:

| 作业 | 到达时间 | 运行时间 |
| ---- | -------- | -------- |
| A    | 8:00     | 2.0小时  |
| B    | 8:30     | 1.0小时  |
| C    | 9:00     | 0.5小时  |
| D    | 9:30     | 0.3小时  |

**要求**:

1. 分别采用FCFS和SJF算法，写出调度顺序
2. 计算每个作业的周转时间和带权周转时间
3. 计算平均周转时间和平均带权周转时间
4. 比较两种算法的性能

------

## 题目2: 时间片轮转调度

有5个进程P1、P2、P3、P4、P5，它们的到达时间和服务时间如下:

| 进程 | 到达时间 | 服务时间 |
| ---- | -------- | -------- |
| P1   | 0        | 4        |
| P2   | 1        | 3        |
| P3   | 2        | 5        |
| P4   | 3        | 2        |
| P5   | 4        | 4        |

**要求**:

1. 采用时间片轮转算法，时间片q=2，画出进程调度的甘特图
2. 计算每个进程的周转时间和带权周转时间
3. 计算平均周转时间和平均带权周转时间
4. 如果时间片改为q=1，重新计算平均周转时间，并分析时间片大小对性能的影响

------

## 题目3: 高响应比优先调度

有3个作业J1、J2、J3同时到达系统（到达时间均为0），它们的运行时间分别为:

| 作业 | 运行时间 |
| ---- | -------- |
| J1   | 5        |
| J2   | 3        |
| J3   | 7        |

又有两个作业J4和J5分别在时刻2和时刻4到达:

| 作业 | 到达时间 | 运行时间 |
| ---- | -------- | -------- |
| J4   | 2        | 2        |
| J5   | 4        | 4        |

**要求**:

1. 采用高响应比优先调度算法（非抢占式），写出详细的调度过程
2. 在每次调度时，列出所有就绪作业的响应比计算过程
3. 计算每个作业的周转时间和带权周转时间
4. 计算平均周转时间和平均带权周转时间
5. 说明高响应比优先算法如何平衡短作业和长作业

------

## 参考答案要点

### 题目1答案要点:

**FCFS调度顺序**: A → B → C → D

| 作业 | 完成时间 | 周转时间 | 带权周转时间 |
| ---- | -------- | -------- | ------------ |
| A    | 10:00    | 2.0      | 1.0          |
| B    | 11:00    | 2.5      | 2.5          |
| C    | 11:30    | 2.5      | 5.0          |
| D    | 11:48    | 2.3      | 7.67         |

- 平均周转时间 = 2.325小时
- 平均带权周转时间 = 4.04

**SJF调度顺序**: A → D → C → B

| 作业 | 完成时间 | 周转时间 | 带权周转时间 |
| ---- | -------- | -------- | ------------ |
| A    | 10:00    | 2.0      | 1.0          |
| D    | 10:18    | 0.8      | 2.67         |
| C    | 10:48    | 1.8      | 3.6          |
| B    | 11:48    | 3.3      | 3.3          |

- 平均周转时间 = 1.975小时
- 平均带权周转时间 = 2.64

**性能对比**: SJF在两个指标上都优于FCFS

### 题目2答案要点:

**时间片q=2的调度过程**（甘特图关键时刻）:

- 0-2: P1, 2-4: P2, 4-6: P3, 6-8: P4完成+P5, 8-10: P1完成+P2, 10-12: P3, 12-14: P5, 14-16: P3完成+P5完成

**时间片大小影响**:

- 时间片越小→响应时间越短，但调度开销越大
- 时间片越大→调度开销越小，但响应时间越长

### 题目3答案要点:

**调度过程**:

- 时刻0: J2响应比最高(1.0，但运行时间最短) → 选J2
- 时刻3: 计算J1、J3、J4响应比 → 选响应比最高者
- 依此类推...

**关键点**: 高响应比 = 等待时间长或运行时间短，兼顾公平性
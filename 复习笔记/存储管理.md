# 操作系统存储管理复习笔记

## 一、存储管理概述

> 对应教材：第5章 5.1 存储器层次结构、5.2 程序的装入与链接，P137～143

### 1. 存储器层次结构

计算机系统采用**多级存储器结构**，按速度和容量形成层次:

```
寄存器 (最快，最小)
    ↓
高速缓存 (Cache)
    ↓
主存 (内存) ← CPU可直接访问，易失性
    ↓
磁盘缓存
    ↓
磁盘 (辅存) ← CPU不可直接访问，非易失性
    ↓
可移动存储介质 (最慢，最大)
```

### 2. 地址的基本概念

**① 物理地址 (Physical Address, PA)**:

- 内存以**字节**为单位编址
- 从0编号到2^m - 1
- 所有物理地址的集合称为**物理地址空间**

**② 逻辑地址 (Logical Address, LA)**:

- 程序中使用的地址
- 从0开始编址
- 与实际物理位置无关

### 3. 地址重定位 (Address Relocation)

**定义**: 将逻辑地址转换为物理地址的过程，也称**地址映射**。

#### (1) 静态重定位

**时机**: 程序装入内存时**一次性**完成地址转换

**特点**:

- ✅ 简单，无需硬件支持
- ❌ 程序装入后不能移动
- ❌ 内存利用率低

**示例**:

```
逻辑地址:  Load R1, 500
装入地址:  5000
物理地址:  Load R1, 5500 (一次性转换完成)
```

#### (2) 动态重定位

**时机**: 程序运行过程中，**每次访问内存前**进行地址转换

**特点**:

- ✅ 程序可在内存中移动
- ✅ 内存利用率高
- ❌ 需要硬件支持(基址寄存器、限长寄存器)
- ❌ 每次访存都要转换

**硬件支持**:

- **基址寄存器**: 存放分区起始地址
- **限长寄存器**: 存放分区大小

**地址转换公式**:

```
PA = LA + 基址寄存器
```

**地址保护**:

```
基址寄存器 ≤ PA ≤ 基址寄存器 + 限长寄存器
```

### 4. 存储管理的功能

1. **内存的描述与组织**: 确定内存单元的描述方式和组织结构
2. **内存分配与回收**: 分配算法和回收算法
3. **地址转换**: 逻辑地址→物理地址
4. **存储保护**: 防止进程间相互干扰
5. **存储扩充**: 提供比物理内存更大的虚拟空间

### 5. 程序的装入、链接与地址绑定（教材补充）

#### (1) “编译 → 链接 → 装入”三阶段

| 阶段       | 主要工作                               | 产生文件           | 考点提示                           |
| ---------- | -------------------------------------- | ------------------ | ---------------------------------- |
| **编译**   | 词法/语法/语义分析，生成目标模块       | `.obj`/`.o`        | 语句级别错误在此被捕获             |
| **链接**   | 目标模块+库函数重定位、符号解析        | **装入模块**       | 静态链接 vs 动态链接               |
| **装入**   | 将装入模块调入内存，建立地址映射       | **内存映像**       | 绝对/可重定位/动态运行时装入       |

> 大纲常问“地址绑定在何时完成？”——教材强调：越往后绑定，程序越容易移动/共享，但对硬件支持要求更高。

#### (2) 三种装入方式对比

| 装入方式           | 地址绑定时机        | 适用场景/优缺点                                         |
| ------------------ | ------------------- | -------------------------------------------------------- |
| **绝对装入**       | 编译/链接阶段       | 目标程序含物理地址，装入位置固定；实现最简单但无法移动   |
| **可重定位装入**   | 装入阶段            | 目标程序含相对地址 + 重定位表，装入器据基址统一修正     |
| **动态运行时装入** | 运行阶段（每次访存) | 依赖基址/限长寄存器或段表/页表；支持对换、动态装入/共享 |

#### (3) 链接方式一览

- **静态链接**：编译期一次性把所有目标模块+库函数装配成可执行文件。优点是装入快；缺点是占内存、更新库要重链。
- **装入时动态链接**：仅在需要时把模块链接进来（装入时按需合并符号），节省内存并允许不同程序共享更新后的库。
- **运行时动态链接**：运行中再装入共享库（如 `dlopen`/DLL），真正调用到某函数时才解析符号；灵活但需额外开销和接口稳定性。

#### (4) 内存保护与重定位硬件

- **基址寄存器 + 限长寄存器**：每次访存先做界限检查，再由基址寄存器完成动态映射。教材强调“基址 ≤ PA ≤ 基址+限长”。
- **上下界/界限寄存器**：有的架构直接保存下界和上界，本质等价，常在单道+可变分区系统考查。
- **存储保护键/页表保护位**：大型机用存储保护键；分页/分段用R/W/X位。共享代码段需设置只读，数据段可写。
- **动态装入/共享**依赖上述硬件：同一物理块可被多个页表或段表引用，但必须靠访问位严格隔离。

### 6. 覆盖与对换（教材补充，易混考点）

| 技术     | 核心思想                                               | 触发者           | 需要硬件              | 典型场景/代价                               |
| -------- | ------------------------------------------------------ | ---------------- | --------------------- | -------------------------------------------- |
| **覆盖** | 按调用关系把程序划成常驻区+多个覆盖段，互斥段复用同块  | **程序员/链接器** | 否（静态布置即可）    | 早期小内存系统，需人工维护覆盖树             |
| **对换** | 整个进程映像在内存与外存（对换区）之间成批换入/换出   | **OS/调度器**     | 动态重定位 + 对换区   | 提高多道并发但磁盘I/O代价高，需保存PCB状态  |

- **覆盖**仅在单进程内部切换段，不改变进程在调度队列中的状态；常驻区保存公共子程序/数据。优点是无需额外硬件，缺点是人工配置繁琐且只适合顺序结构。
- **对换（Swapping）**在进程级运作：阻塞或低优先级进程被换出到对换区，腾出整块内存；回调时再换入，并通过基址/页表更新地址映射。
- 教材提示：覆盖是逻辑扩充内存的**静态方案**，对换/虚拟存储则是OS的**动态方案**；两者常搭配考辨析题。

------

## 二、实存管理 - 连续分配方式

> 对应教材：第5章 5.4 连续分配存储管理方式，P147～151

### 1. 固定分区存储管理

#### 基本思想

- 物理内存被OS预先划分成若干个**固定大小**的分区
- 每个分区最多装入**一个作业**
- 分区大小和个数**固定不变**

#### 内存的描述与组织

**分区描述** (结构体变量):

- 分区号
- 大小
- 起始地址
- 状态 (0=空闲, 1=已分配)

**组织方式**: **分区表** (数组)

| 分区号 | 大小 | 起始地址 | 状态 |
| ------ | ---- | -------- | ---- |
| 1      | 8K   | 312K     | 0    |
| 2      | 32K  | 320K     | 0    |
| 3      | 32K  | 352K     | 0    |
| 4      | 128K | 384K     | 0    |
| 5      | 512K | 512K     | 0    |

#### 分配与回收算法

**分配算法**:

```c
分配(作业大小usize) {
    for (i = 1 to n) {
        if (p[i].status == 0 && p[i].size >= usize) {
            p[i].status = 1;
            return i;  // 返回分区号
        }
    }
    printf("无法分配");
}
```

**回收算法**:

```c
回收(分区号pid) {
    p[pid].status = 0;
}
```

#### 地址映射

**公式**: `PA = LA + 分区起始地址`

**硬件支持**: 基址寄存器 (习题1答案A)
> 习题1 原题：*.固定分区存储管理中，处理器设置的地址转换机构是____________。  
> 选项：A. 基址寄存器 B. 限长寄存器 C. 基址寄存器和限长寄存器  
> 答案：A

#### 优缺点

**优点**:

- ✅ 实现简单(数据结构、算法简单)
- ✅ 支持多道程序

**缺点**:

- ❌ 存在**内碎片**(分区内部无法使用的空间)
- ❌ 并发度受限(受分区个数限制)
- ❌ 作业大小受限(不能超过最大分区)

------

### 2. 可变分区存储管理 ⭐⭐⭐

#### 基本思想

- 作业装入内存时才划分分区
- 根据作业大小"量体裁衣"
- 分区的**个数**和**大小**都是可变的

**彻底解决了内碎片问题**

#### 内存的描述与组织

**分区描述**:

- 大小
- 起始地址
- 链接指针(单链或双链)

**组织方式**: **链表** (分区个数可变)

**两个链表**:

- **作业链**: 已分配给作业的分区
- **空闲分区链**: 所有空闲分区

#### 分配算法 (调度算法通过队列排序体现) ⭐⭐⭐

**① 首次适应算法 (First Fit, FF)**

**排队原则**: 空闲分区按**起始地址递增**排列

**分配策略**: 选择**第一个**大小满足要求的空闲分区

**特点**:

- ✅ 实现简单
- ✅ 高地址大分区保留较好
- ❌ 低地址产生小碎片

------

**② 循环首次适应算法 (Next Fit, NF)**

**排队原则**: 与首次适应相同

**分配策略**: 从**上次分配位置的下一个**分区开始查找

**特点**:

- ✅ 分配更均匀
- ❌ 大分区容易被分割

------

**③ 最佳适应算法 (Best Fit, BF)**

**排队原则**: 空闲分区按**大小递增**排列

**分配策略**: 选择**最小的**满足要求的空闲分区

**特点**:

- ✅ 大分区保留较好
- ❌ 以最快速度产生碎片
- ❌ 产生大量无法利用的小碎片

**习题对应**: 习题5答案B、习题14答案D
> 习题5 原题：内存分配的最佳适应算法的空闲区表是____________。  
> 选项：A. 按大小递减顺序排列 B. 按大小递增顺序排列 C. 按地址由小到大排列 D. 按地址由大到小排列  
> 答案：B  
> 习题14 原题：在可变分区存储管理中，最优适应分配算法要求对空闲区表项按____________进行排列。  
> 选项：A. 地址从大到小 B. 地址从小到大 C. 尺寸从大到小 D. 尺寸从小到大  
> 答案：D

------

**④ 最坏适应算法 (Worst Fit, WF)**

**排队原则**: 空闲分区按**大小递减**排列

**分配策略**: 选择**最大的**空闲分区

**特点**:

- ✅ 分割后剩余分区较大，可继续使用
- ❌ 大作业找不到合适分区

**习题对应**: 习题12答案A、习题13答案D
> 习题12 原题：在可变分区分配方案中，在空闲区表中以空闲区长度按递减顺序排列适合于________算法。  
> 选项：A. 最坏适应算法 B. 最先适应算法 C. 最优适应算法 D. 首次循环适应算法  
> 答案：A  
> 习题13 原题：假设某计算机系统的内存大小为2560KB，采用可变分区管理内存，在某一时刻内存的使用情况如下表所示（始址/状态/容量依次为：0K 已用 200K；200K 未用 300K；500K 已用 500K；1000K 未用 50K；1050K 已用 300K；1350K 未用 250K；1600K 已用 150K；1750K 未用 200K；1950K 已用 400K；2350K 未用 210K）。此时若进程顺序请求200K、100K和50K的存储空间，系统采用某种内存分配算法为进程依次分配内存，分配后的内存使用情况如题面所示，问该系统采用的内存分配算法是____________适应算法。  
> 选项：A. 首次 B. 循环首次 C. 最佳 D. 最坏  
> 答案：D

------

**算法对比表**:

| 算法         | 排队原则       | 优点                     | 缺点           | 习题   |
| ------------ | -------------- | ------------------------ | -------------- | ------ |
| **首次适应** | 地址递增       | 简单，高地址大分区保留好 | 低地址小碎片多 | 16     |
| **循环首次** | 地址递增(循环) | 分配均匀                 | 大分区易被分割 | 15     |
| **最佳适应** | 大小递增       | 大分区保留好             | 快速产生小碎片 | 5, 14  |
| **最坏适应** | 大小递减       | 剩余分区可用             | 大作业难分配   | 12, 13 |

#### 回收算法 - 分区合并 ⭐⭐⭐

回收时需要判断**回收分区H**与**空闲分区F**的邻接关系:

**情况1**: H与任何F不相邻

```
处理: 直接将H插入空闲分区链
```

**情况2**: H是F的下邻

```
判断: F.address + F.size == H.address
处理: F.size = F.size + H.size
```

**情况3**: H是F的上邻

```
判断: H.address + H.size == F.address
处理: F.address = H.address
      F.size = F.size + H.size
```

**情况4**: H是F1的下邻，是F2的上邻

```
判断: F1.address + F1.size == H.address
      H.address + H.size == F2.address
处理: F1.size = F1.size + H.size + F2.size
      delete(F2)
```

#### 碎片问题

**外碎片**: 分区之间**无法使用**的小空闲区

**特点**: ①大量 ②分散 ③太小

**解决方法**:

- **拼接(紧凑)**: 移动内存中的作业，合并碎片
  - 代价大(需要移动大量数据)
  - 不彻底(仍会产生新碎片)

**习题8计算示例**:

初始: 55MB空闲

操作序列:

1. 分配15MB → 剩余40MB
2. 分配30MB → 剩余10MB
3. 释放15MB → 空闲: 15MB(前) + 10MB(后)
4. 分配8MB → 从15MB分配，剩余7MB
5. 分配6MB → 从10MB分配，剩余4MB

内存布局:

```
[已分配30MB][剩余7MB][已分配8MB][已分配6MB][剩余4MB]
```

**最大空闲分区**: 7MB + 4MB = 11MB? **错**: 不相邻不能合并 **正确答案**: 7MB (但题目答案是9MB，可能有误)
> 习题8 原题：某基于动态分区存储管理的计算机，主存容量为55MB（初始为空闲），采用最佳适配（Best Fit）算法，分配和释放的顺序为：分配15MB、分配30MB、释放15MB、分配8MB、分配6MB，此时主存中最大空闲分区的大小是____________。  
> 选项：A. 7MB B. 9MB C. 10MB D. 15MB  
> 答案：B

#### 优缺点

**优点**:

- ✅ 解决了内碎片问题
- ✅ 并发度不受限
- ✅ 作业大小不受固定值限制

**缺点**:

- ❌ 实现复杂(链表、多种算法、4种邻接关系)
- ❌ 存在外碎片
- ❌ 需要硬件支持(基址、限长寄存器)

------

## 三、离散分配方式

> 对应教材：第5章 5.5、5.6 分页/分段/段页式存储管理，P152～166 左右

### 核心思想

**问题**: 连续分配产生碎片的根本原因是什么?

- 作业要求**连续**的物理内存
- 作业大小不一

**解决**: 将作业分成多个部分，分别装入**不连续**的内存区域

- **离散分配** - 彻底解决碎片问题

------

### 1. 分页存储管理 ⭐⭐⭐

#### 基本思想

1. 将物理内存分成**大小相等**的**块 (Block, 物理块, 页框, Page Frame)**
   - 块大小 = 2^n 字节 (如256B, 512B, 1KB, 2KB, 4KB)
2. 将作业分成**大小相等**的**页 (Page, 逻辑页)**
3. **页大小 = 块大小**
4. 一个逻辑页恰好装入一个物理块

#### 内存的描述与组织

**物理内存**: 以**块**为单位编址

- 块号: 0 到 2^(m-n) - 1

**块的描述**:

- 块号
- 状态 (0=空闲, 1=已分配)

**组织方式**: **块表** (数组，类似固定分区表)

#### 分配与回收

**分配算法**: 类似固定分区，找第一个空闲块 **回收算法**: 将状态置0

#### 关键数据结构 - 页表 ⭐⭐⭐

**作用**: 记录作业的每个**逻辑页**装入哪个**物理块**

**页表结构** (基本分页):

| 页号 | 块号 |
| ---- | ---- |
| 0    | 256  |
| 1    | 260  |
| 2    | n    |
| 3    | 262  |

**存放位置**: 内存

**访问方式**: 页表首地址存放在**页表寄存器 (PTR)**

- PTR包含: 页表始址B, 页表长度L

#### 地址映射 ⭐⭐⭐ (必考)

**逻辑地址结构** (32位系统，页大小4KB=2^12):

```
┌─────────────┬────────────┐
│  页号 p     │ 页内偏移 d  │
│ 31 ... 12   │  11 ... 0  │
└─────────────┴────────────┘
     20位          12位
```

**地址映射步骤**:

**步骤1**: 计算页号p和页内偏移d

```
方法1 (数学):
p = LA / pagesize
d = LA % pagesize

方法2 (位操作，CPU擅长):
p = LA的高20位
d = LA的低12位
```

**示例**: LA = 5000B, pagesize = 4KB = 4096B

```
p = 5000 / 4096 = 1
d = 5000 % 4096 = 904
```

**步骤2**: 查页表，获得块号b

```
从页表寄存器获取页表地址
根据页号p查页表: b = PageTable[p]
```

**步骤3**: 计算物理地址PA

```
PA = b × pagesize + d
```

**完整示例**:

```
LA = 5000B
pagesize = 4KB = 4096B

步骤1: p = 1, d = 904
步骤2: 查页表，PageTable[1] = 260
步骤3: PA = 260 × 4096 + 904 = 1065864B
```

**习题21答案**:

```
LA = 4688B
pagesize = 2KB = 2048B

p = 4688 / 2048 = 2
d = 4688 % 2048 = 592

查页表: PageTable[2] = 6
PA = 6 × 2048 + 592 = 12880B
```
> 习题21 原题：在采用页式存储管理的系统中，某作业的逻辑地址空间为4页（每页2048字节），页表为：页号0→内存块2、页号1→块4、页号2→块6、页号3→块9。求逻辑地址4688对应的物理地址。  
> 答案：12880B

#### 性能优化

**问题1**: 除法和乘法运算慢

**解决**: **地址分页机构** (硬件)

- 通过位操作快速拆分和拼接地址
- 将LA的高位作为p，低位作为d
- 将b和d拼接成PA

**问题2**: 访问页表需要额外访存 (性能腰斩)

**解决**: **快表 (TLB, Translation Lookaside Buffer)**

- 高速缓存(Cache)，存放部分页表项
- 与查页表**并行**进行

**地址映射步骤 (有快表)**:

1. CPU给出LA，地址分页机构拆分成(p, d)
2. **同时**:
   - 查快表: 查找页号p
   - 查页表: 访问内存中的页表
3. 如果快表命中 → 直接获得块号b
4. 如果快表未命中 → 使用页表结果，并将该页表项加入快表
5. 地址分页机构拼接(b, d)得到PA

**有效访问时间 (EAT) 计算** ⭐⭐⭐:

```
设:
- 查快表时间 = a (如50ns)
- 访存时间 = m (如750ns)
- 快表命中率 = h

EAT = h × (a + m) + (1-h) × (a + 2m)
    = a + m + (1-h) × m
```

**示例** (习题61):

```
a = 50ns, m = 750ns

命中率90%:
EAT = 50 + 750 + 0.1×750 = 875ns
延迟 = (875-750)/750 = 16.7%

命中率97%:
EAT = 50 + 750 + 0.03×750 = 822.5ns
延迟 = (822.5-750)/750 = 9.7%
```

**习题20答案**: 快表失败时，要读**2次**主存(页表+数据)
> 习题20 原题：页式存储管理中，每次从主存中取指令或取操作数，当读快表失败时，要读____________次主存。  
> 选项：A.1 B.2 C.3 D.4  
> 答案：B

#### 两级页表

**问题**: 32位系统，页大小4KB

- 页表项数 = 2^32 / 2^12 = 2^20 = 1M个
- 每个页表项4B → 页表大小 = 4MB
- 一个物理块(4KB)只能装256个页表项

**解决**: 将页表分页 → **两级页表**

**逻辑地址结构**:

```
┌──────────┬──────────┬────────────┐
│ 页目录号  │  页表号   │ 页内偏移 d  │
│  10位    │  10位    │   12位     │
└──────────┴──────────┴────────────┘
```

**习题31**: Windows 2000的两级页表

- 页目录索引 (10位) → 页目录表项数 = 2^10 = **1024**
- 页内偏移 (12位) → 页大小 = 2^12 = **4096**字节

**答案**: D
> 习题31 原题：Windows 2000 采用二级页表，其逻辑地址结构为“页目录索引dir(10位) / 页表页索引page(10位) / 页内偏移offset(12位)”，问页目录的表项数和页的大小分别是____________。  
> 选项：A. 10和12 B. 20和12 C. 1M和4K D. 1024和4096  
> 答案：D

#### 优缺点

**优点**:

- ✅ **彻底解决外碎片**
- ✅ 分配回收简单
- ✅ 内存利用率高

**缺点**:

- ❌ **页内碎片** (最后一页未装满)
- ❌ 地址映射复杂
- ❌ 需要硬件支持多(页表、PTR、地址分页机构、快表)
- ❌ 存在**两次访存**问题 (即使用快表也有延迟)
- ❌ **难以实现共享** (机械分页，不考虑逻辑结构)

------

### 2. 分段存储管理

#### 基本思想

**解决问题**: 分页难以实现共享(如多个程序共享stdio.h)

**核心**: 按**逻辑结构**分割作业

- 每个段是一组**逻辑相关**的信息集合
- 如: 主程序段、子程序段、数据段、堆栈段

**特点**:

- 段大小**不相等**
- **段内连续，段间离散**

#### 内存的描述与组织

**物理内存**: 不分块，以**分区**为单位

- 类似**可变分区**

**段的描述**: 段表

| 段号 | 段长 | 段始址 | 存取控制 |
| ---- | ---- | ------ | -------- |
| 0    | K    | 3200   | RW       |
| 1    | P    | 1500   | R        |
| 2    | L    | 6000   | RWX      |

#### 地址结构

**二维地址**: (段号s, 段内偏移d)

**示例**: (2, 1500) 表示第2段的偏移1500处

#### 地址映射

**步骤**:

1. 检查s < 段表长度 (地址保护)
2. 检查d < 段表[s].段长 (地址保护)
3. PA = 段表[s].段始址 + d

**习题23答案**: 段内偏移 > 段长 → **地址越界中断** (D)
> 习题23 原题：在段式存储管理的地址转换时，若段内地址大于段表中该段的长度，则发生 ___________。  
> 选项：A. 缺页中断 B. 溢出中断 C. 硬件故障中断 D. 地址越界中断  
> 答案：D

#### 优缺点

**优点**:

- ✅ **支持共享** (相同逻辑段只装入一次)
- ✅ **支持动态链接** (不必全部装入)
- ✅ 逻辑清晰

**缺点**:

- ❌ **外碎片** (段大小不等)
- ❌ 分配回收复杂 (类似可变分区)
- ❌ 两次访存问题

**习题24答案**: 每一段必须是**连续**的存储区 (B)
> 习题24 原题：下列选项中，对分段存储管理叙述正确的是____________。  
> 选项：A. 每个段必须是大小相等的 B. 每一段必须是连续的存储区 C. 每一段不必是连续的存储区 D. 段之间的存储区必须是连续的  
> 答案：B

------

### 3. 段页式存储管理 ⭐⭐⭐

#### 基本思想

**目标**: 既要共享(分段优点)，又要无碎片(分页优点)

**方法**: 先分段，再对段分页

**步骤**:

1. 物理内存分块
2. 作业分段
3. 段内分页
4. 页大小 = 块大小

#### 地址结构

```
┌──────┬──────┬──────┐
│ 段号s │ 页号p │ 页内d │
└──────┴──────┴──────┘
   ↑        ↑
   │        └─ 段内地址w
   └────────── 段号
```

#### 数据结构

**段表** + **页表**

**段表**:

| 段号 | 页表长度 | 页表始址 | 存取控制 |
| ---- | -------- | -------- | -------- |
| 0    | L'       | B'       | RWX      |

**页表** (每个段一个):

| 页号 | 块号 |
| ---- | ---- |
| 0    | b0   |
| 1    | b1   |

#### 地址映射

**无快表**:

1. 检查s < 段表长度
2. 读段表，获得页表始址B'和页表长度L'
3. 根据w计算: p = w / pagesize, d = w % pagesize
4. 检查p < L'
5. 读页表[p]，获得块号b
6. PA = b × pagesize + d

**访存次数**: **3次** (段表 + 页表 + 数据)

**习题28, 30答案**: 快表失败时，**3次**访存
> 习题28 原题：段页式存储管理中，每次从主存中取指令或取操作数，当读快表失败时，至少要____________次访问主存。  
> 选项：A.0 B.1 C.2 D.3  
> 答案：D  
> 习题30 原题：段页式存储管理中，访问快表失败时，每访问一条指令或存取一个操作数都要____________次访问主存。  
> 选项：A.1 B.2 C.3 D.4  
> 答案：C

**有快表**:

- 同时查快表和段表/页表
- 快表存储: (段号, 页号) → 块号

#### 优缺点

**优点**:

- ✅ 支持共享
- ✅ 支持动态链接
- ✅ 无外碎片

**缺点**:

- ❌ **三次访存** (即使快表也有延迟)
- ❌ 硬件支持最多
- ❌ 更多页内碎片 (每个段的最后一页)

------

## 四、虚拟存储器 (Virtual Memory)

> 对应教材：第6章 虚拟存储器，P167 以后

### 1. 虚存的三要素

#### (1) 理论基础 - 程序局部性原理

**定义**: 程序在执行过程中的一个较短时期内，所执行的指令地址和操作数地址，分别局限于一定区域。

**两种局部性**:

**① 时间局部性**:

- 一段指令在某一时间段内会被**反复执行**
- 如: 循环结构

**② 空间局部性**:

- 一旦某个存储单元被访问，其**附近的单元**也将很快被访问
- 如: 顺序结构、数组访问

#### (2) 技术手段 - 对换

**核心思想**: 只装入**部分页面**即可运行

**关键机制**:

**① 请调 (Demand Paging)**:

- 发生**缺页**时才调入
- 靠谱，效果好

**② 预调**:

- 预测并提前调入
- 准确率低

**③ 置换**:

- 内存满时，换出部分页面，再调入新页面

#### (3) 物质基础

一定容量的**内存** + 相当容量的**辅存**

**逻辑效果**: 两级存储器合成一级**虚拟存储器**

- 容量 = 内存 + 辅存 (远大于物理内存)
- 速度介于两者之间

------

### 2. 虚存管理策略

#### 物理内存分配策略

**① 固定分配**:

- 进程生存期内分得的物理块数**不变**

**② 可变分配**:

- 根据缺页频率**动态调整**物理块数
- 缺页频繁 → 增加块数
- 缺页少 → 减少块数

#### 调入策略

**① 预调**: 预测并提前调入 (准确率低) **② 请调**: 缺页时调入 (实用)

#### 置换策略

**① 局部置换**:

- 在发生缺页的**进程内部**置换
- 谁缺页，换谁的页面

**② 全局置换**:

- 在**整个物理内存**范围内置换

- 效果更好

  ------

  ### 3. 请求分页存储管理 ⭐⭐⭐

  #### 与基本分页的区别

  | 项目     | 基本分页     | 请求分页 |
  | -------- | ------------ | -------- |
  | 装入方式 | 全部装入     | 部分装入 |
  | 页表结构 | (页号, 块号) | 扩展页表 |
  | 中断机制 | 无           | 缺页中断 |

  #### 扩展页表

  | 页号 | 块号 | 状态位 | 辅存地址 | 访问位 | 修改位 |
  | ---- | ---- | ------ | -------- | ------ | ------ |
  | 0    | 256  | 1      | -        | 1      | 0      |
  | 1    | -    | 0      | Disk123  | 0      | 0      |

  **字段说明**:

  **① 状态位**:

  - 1 = 页面在内存
  - 0 = 页面在辅存

  **② 辅存地址**:

  - 页面在辅存中的位置

  **③ 访问位**:

  - 记录页面是否被访问
  - 为置换算法提供依据

  **④ 修改位**:

  - 记录页面是否被修改
  - 决定换出时是否需要写回辅存
  - 1 = 被修改，需要写回
  - 0 = 未修改，直接覆盖

  #### 缺页中断处理 ⭐⭐⭐

  **缺页中断特点**:

  | 特性     | 普通中断   | 缺页中断             |
  | -------- | ---------- | -------------------- |
  | 发生时机 | 指令结束   | **指令执行期间**     |
  | 返回断点 | 下一条指令 | **当前指令**         |
  | 发生频率 | 一次       | **一条指令可能多次** |

  **处理流程**:

  1. 保存CPU现场
  2. **查页表**，确认缺页
  3. **内存满否?**
     - 否 → 步骤6
     - 是 → 步骤4
  4. **选择一页换出** (置换算法)
  5. **该页被修改否?**
     - 是 → 写回辅存
     - 否 → 直接覆盖
  6. 从辅存调入缺页
  7. **修改页表** (状态位=1, 块号, 访问位)
  8. 修改快表
  9. 恢复CPU现场，**重新执行**当前指令

  ------

  ### 4. 页面置换算法 ⭐⭐⭐ (必考大题)

  #### 基本概念

  **① 页面走向**: 程序执行过程中对页面的访问顺序

  **② 命中**: 要访问的页面在内存

  **③ 缺页**: 要访问的页面不在内存

  **④ 缺页率**:

  ```
  缺页率 = 缺页次数 / 总访问页面数
  命中率 = 1 - 缺页率
  ```

  **⑤ 置换**: 内存满时，选择一页换出，再调入新页

  ------

  #### (1) 最佳置换算法 (OPT, Optimal) ⭐⭐⭐

  **原理**: 淘汰**以后永不使用**或**未来最长时间不访问**的页面

  **特点**:

  - ✅ 缺页率最低 (理论最优)
  - ❌ 无法实现 (需要预知未来)
  - ✅ 用于评估其他算法

  **示例**:

  物理块数 = 3

  页面走向: 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1

  | 时刻  | 访问页 | 块1   | 块2   | 块3   | 缺页?     |
  | ----- | ------ | ----- | ----- | ----- | --------- |
  | 1     | 7      | 7     | -     | -     | ✓         |
  | 2     | 0      | 7     | 0     | -     | ✓         |
  | 3     | 1      | 7     | 0     | 1     | ✓         |
  | 4     | 2      | **2** | 0     | 1     | ✓ (淘汰7) |
  | 5     | 0      | 2     | 0     | 1     | -         |
  | 6     | 3      | 2     | 0     | **3** | ✓ (淘汰1) |
  | 7     | 0      | 2     | 0     | 3     | -         |
  | 8     | 4      | **4** | 0     | 3     | ✓ (淘汰2) |
  | 9     | 2      | 4     | 0     | **2** | ✓ (淘汰3) |
  | 10    | 3      | 4     | **3** | 2     | ✓ (淘汰0) |
  | 11    | 0      | **0** | 3     | 2     | ✓ (淘汰4) |
  | 12-20 | ...    | ...   | ...   | ...   | ...       |

  **缺页次数**: 9次 (具体需完整计算)

  ------

  #### (2) 先进先出算法 (FIFO) ⭐⭐⭐

  **原理**: 淘汰**最先进入内存**的页面 (驻留时间最长)

  **实现**: 队列，新页面从队尾进，淘汰队首页面

  **特点**:

  - ✅ 实现简单
  - ❌ 性能较差
  - ❌ **Belady异常**: 增加物理块数反而增加缺页次数

  **示例**:

  页面走向: 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1

  **3个物理块**:

  | 时刻 | 访问 | 块1   | 块2   | 块3   | 缺页? | 队首 |
  | ---- | ---- | ----- | ----- | ----- | ----- | ---- |
  | 1    | 7    | 7     | -     | -     | ✓     | 7    |
  | 2    | 0    | 7     | 0     | -     | ✓     | 7    |
  | 3    | 1    | 7     | 0     | 1     | ✓     | 7    |
  | 4    | 2    | **2** | 0     | 1     | ✓     | 0    |
  | 5    | 0    | 2     | 0     | 1     | -     | 0    |
  | 6    | 3    | 2     | **3** | 1     | ✓     | 1    |
  | 7    | 0    | 2     | 3     | 1     | -     | 1    |
  | 8    | 4    | 2     | 3     | **4** | ✓     | 2    |
  | 9    | 2    | 2     | 3     | 4     | -     | 2    |
  | 10   | 3    | 2     | 3     | 4     | -     | 2    |
  | 11   | 0    | **0** | 3     | 4     | ✓     | 3    |
  | 12   | 3    | 0     | 3     | 4     | -     | 3    |
  | 13   | 2    | 0     | **2** | 4     | ✓     | 4    |
  | 14   | 1    | 0     | 2     | **1** | ✓     | 0    |
  | 15   | 2    | 0     | 2     | 1     | -     | 0    |
  | 16   | 0    | 0     | 2     | 1     | -     | 0    |
  | 17   | 1    | 0     | 2     | 1     | -     | 0    |
  | 18   | 7    | **7** | 2     | 1     | ✓     | 2    |
  | 19   | 0    | 7     | **0** | 1     | ✓     | 1    |
  | 20   | 1    | 7     | 0     | 1     | -     | 1    |

  **缺页次数**: 12次 **缺页率**: 12/20 = 60%

  **Belady异常示例** (4个物理块):

  同样的页面走向，用4个物理块反而缺页13次 (详见PPT)

  ------

  #### (3) 最近最久未使用算法 (LRU, Least Recently Used) ⭐⭐⭐

  **原理**: 淘汰**最近最久未使用**的页面

  **依据**: 根据程序的局部性原理，最近使用过的页面，未来可能还会使用

  **实现方法**:

  **方法1 - 记时法**:

  - 每个页面设置**时间戳**
  - 访问页面时，更新时间戳为当前时间
  - 淘汰时选择时间戳**最小**的页面

  **方法2 - 堆栈法** (推荐):

  - 用栈保存页号
  - 访问页面时，将该页从栈中移到**栈顶**
  - 淘汰**栈底**页面

  **特点**:

  - ✅ 性能接近OPT
  - ✅ 不会出现Belady异常
  - ❌ 实现开销大 (需要维护时间戳或栈)

  **示例**:

  页面走向: 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1

  **3个物理块 (堆栈法)**:

  | 时刻 | 访问 | 栈顶→栈底 | 缺页? | 说明         |
  | ---- | ---- | --------- | ----- | ------------ |
  | 1    | 7    | 7         | ✓     | 装入7        |
  | 2    | 0    | 0→7       | ✓     | 装入0        |
  | 3    | 1    | 1→0→7     | ✓     | 装入1        |
  | 4    | 2    | 2→1→0     | ✓     | 淘汰7，装入2 |
  | 5    | 0    | 0→2→1     | -     | 0移到栈顶    |
  | 6    | 3    | 3→0→2     | ✓     | 淘汰1，装入3 |
  | 7    | 0    | 0→3→2     | -     | 0移到栈顶    |
  | 8    | 4    | 4→0→3     | ✓     | 淘汰2，装入4 |
  | 9    | 2    | 2→4→0     | ✓     | 淘汰3，装入2 |
  | 10   | 3    | 3→2→4     | ✓     | 淘汰0，装入3 |
  | 11   | 0    | 0→3→2     | ✓     | 淘汰4，装入0 |
  | 12   | 3    | 3→0→2     | -     | 3移到栈顶    |
  | 13   | 2    | 2→3→0     | -     | 2移到栈顶    |
  | 14   | 1    | 1→2→3     | ✓     | 淘汰0，装入1 |
  | 15   | 2    | 2→1→3     | -     | 2移到栈顶    |
  | 16   | 0    | 0→2→1     | ✓     | 淘汰3，装入0 |
  | 17   | 1    | 1→0→2     | -     | 1移到栈顶    |
  | 18   | 7    | 7→1→0     | ✓     | 淘汰2，装入7 |
  | 19   | 0    | 0→7→1     | -     | 0移到栈顶    |
  | 20   | 1    | 1→0→7     | -     | 1移到栈顶    |

  **缺页次数**: 12次 **缺页率**: 12/20 = 60%

  ------

  #### (4) Clock算法 (NRU, Not Recently Used)

  **原理**: LRU的近似算法，降低实现开销

  **① 简单Clock算法**:

  **实现**:

  - 所有页面组成**循环队列**
  - 每页设置**访问位** (1=被访问，0=未访问)
  - 指针指向下一个待检查页面

  **置换过程**:

  1. 检查指针所指页面的访问位
  2. 访问位=0 → 淘汰该页，结束
  3. 访问位=1 → 置0，指针前进，继续检查

  **特点**:

  - ✅ 实现简单
  - ✅ 开销小
  - ❌ 性能不如LRU

  **② 改进Clock算法**:

  **原理**: 同时考虑**访问位A**和**修改位M**

  **页面分类**:

  | 类别 | (A, M) | 优先级 | 说明                   |
  | ---- | ------ | ------ | ---------------------- |
  | 1类  | (0, 0) | 最高   | 未访问未修改，最佳淘汰 |
  | 2类  | (0, 1) | 中     | 未访问已修改           |
  | 3类  | (1, 0) | 低     | 已访问未修改           |
  | 4类  | (1, 1) | 最低   | 已访问已修改           |

  **置换过程** (三轮扫描):

  **第一轮**: 查找(0, 0)页面

  - 找到 → 淘汰
  - 未找到 → 第二轮

  **第二轮**: 查找(0, 1)页面

  - 扫描过程中，将所有页面的A位置0
  - 找到(0, 1) → 淘汰
  - 未找到 → 第一轮 (此时所有A=0)

  **特点**:

  - ✅ 减少写回磁盘次数 (优先淘汰未修改页)
  - ✅ 性能优于简单Clock

  ------

  #### 算法对比总结

  | 算法      | 原理             | 优点       | 缺点       | 适用       |
  | --------- | ---------------- | ---------- | ---------- | ---------- |
  | **OPT**   | 淘汰未来最久不用 | 缺页率最低 | 无法实现   | 理论评估   |
  | **FIFO**  | 淘汰最先进入     | 实现简单   | Belady异常 | 简单系统   |
  | **LRU**   | 淘汰最久未用     | 性能好     | 实现开销大 | 高性能系统 |
  | **Clock** | LRU近似          | 开销小     | 性能稍差   | 实用系统   |

  ------

  ### 5. 有效访问时间 (EAT) 计算模型 ⭐⭐⭐

  **基本模型**:

  ```
  设:
  - 访存时间 = m
  - 缺页率 = p
  - 缺页处理时间 = s (包括换出+换入)
  
  无虚存: EAT = m
  
  有虚存:
  - 命中 (1-p): m
  - 缺页 (p): s + m
  
  EAT = (1-p) × m + p × (s + m)
      = m + p × s
  ```

  **考虑修改位**:

  ```
  设:
  - 页面被修改概率 = q
  - 写回磁盘时间 = w
  
  缺页处理时间:
  - 页面未修改 (1-q): s
  - 页面已修改 (q): s + w
  
  EAT = m + p × [q × (s+w) + (1-q) × s]
      = m + p × (s + q×w)
  ```

  **示例**:

  ```
  m = 100ns
  p = 0.01 (缺页率1%)
  s = 10ms = 10,000,000ns
  
  EAT = 100 + 0.01 × 10,000,000
      = 100 + 100,000
      = 100,100ns
  
  性能下降: (100,100 - 100) / 100 = 1001倍
  ```

  **减少缺页率的影响** ⭐:

  如果 p = 0.001 (0.1%):

  ```
  EAT = 100 + 0.001 × 10,000,000
      = 100 + 10,000
      = 10,100ns
  
  性能下降: 101倍
  ```

  **结论**: 缺页率对性能影响巨大！

  ------

  ### 6. Belady异常现象

  **定义**: 某些置换算法(如FIFO)中，增加物理块数反而增加缺页次数

  **示例**: 页面走向 0, 1, 2, 3, 0, 1, 4, 0, 1, 2, 3, 4

  **3个物理块** (FIFO):

  - 缺页次数: 9次

  **4个物理块** (FIFO):

  - 缺页次数: 10次

  **结论**:

  - FIFO算法存在Belady异常
  - LRU、OPT不存在Belady异常

  ------

  ## 五、习题生成

  ### 综合计算题1: 页面置换算法对比 ⭐⭐⭐

  **题目**:

  某系统为进程分配了**4个物理块**，页面访问序列如下:

  ```
  1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5, 6, 7, 6, 7, 6, 7, 6, 7
  ```

  要求:

  (1) 分别采用**FIFO算法**和**LRU算法**，画出页面置换过程，计算缺页次数和缺页率。

  (2) 如果访问一次内存的时间为100ns，缺页中断处理时间(包括换出和换入)为10ms，采用FIFO算法时的有效访问时间(EAT)是多少?

  (3) 说明两种算法的性能差异。

  ------

  **答案**:

  **(1) FIFO算法**:

  | 时刻 | 访问 | 块1  | 块2  | 块3  | 块4  | 缺页? | 队首 |
  | ---- | ---- | ---- | ---- | ---- | ---- | ----- | ---- |
  | 1    | 1    | 1    | -    | -    | -    | ✓     | 1    |
  | 2    | 2    | 1    | 2    | -    | -    | ✓     | 1    |
  | 3    | 3    | 1    | 2    | 3    | -    | ✓     | 1    |
  | 4    | 4    | 1    | 2    | 3    | 4    | ✓     | 1    |
  | 5    | 1    | 1    | 2    | 3    | 4    | -     | 1    |
  | 6    | 2    | 1    | 2    | 3    | 4    | -     | 1    |
  | 7    | 5    | 5    | 2    | 3    | 4    | ✓     | 2    |
  | 8    | 1    | 5    | 1    | 3    | 4    | ✓     | 3    |
  | 9    | 2    | 5    | 1    | 2    | 4    | ✓     | 4    |
  | 10   | 3    | 5    | 1    | 2    | 3    | ✓     | 5    |
  | 11   | 4    | 4    | 1    | 2    | 3    | ✓     | 1    |
  | 12   | 5    | 4    | 5    | 2    | 3    | ✓     | 2    |
  | 13   | 6    | 4    | 5    | 6    | 3    | ✓     | 3    |
  | 14   | 7    | 4    | 5    | 6    | 7    | ✓     | 4    |
  | 15   | 6    | 4    | 5    | 6    | 7    | -     | 4    |
  | 16   | 7    | 4    | 5    | 6    | 7    | -     | 4    |
  | 17   | 6    | 4    | 5    | 6    | 7    | -     | 4    |
  | 18   | 7    | 4    | 5    | 6    | 7    | -     | 4    |
  | 19   | 6    | 4    | 5    | 6    | 7    | -     | 4    |
  | 20   | 7    | 4    | 5    | 6    | 7    | -     | 4    |

  **FIFO结果**:

  - 缺页次数: **12次**
  - 缺页率: 12/20 = **60%**
  - 命中率: 40%

  ------

  **(1) LRU算法**:

  | 时刻 | 访问 | 栈顶→栈底 | 缺页?     |
  | ---- | ---- | --------- | --------- |
  | 1    | 1    | 1         | ✓         |
  | 2    | 2    | 2→1       | ✓         |
  | 3    | 3    | 3→2→1     | ✓         |
  | 4    | 4    | 4→3→2→1   | ✓         |
  | 5    | 1    | 1→4→3→2   | -         |
  | 6    | 2    | 2→1→4→3   | -         |
  | 7    | 5    | 5→2→1→4   | ✓ (淘汰3) |
  | 8    | 1    | 1→5→2→4   | -         |
  | 9    | 2    | 2→1→5→4   | -         |
  | 10   | 3    | 3→2→1→5   | ✓ (淘汰4) |
  | 11   | 4    | 4→3→2→1   | ✓ (淘汰5) |
  | 12   | 5    | 5→4→3→2   | ✓ (淘汰1) |
  | 13   | 6    | 6→5→4→3   | ✓ (淘汰2) |
  | 14   | 7    | 7→6→5→4   | ✓ (淘汰3) |
  | 15   | 6    | 6→7→5→4   | -         |
  | 16   | 7    | 7→6→5→4   | -         |
  | 17   | 6    | 6→7→5→4   | -         |
  | 18   | 7    | 7→6→5→4   | -         |
  | 19   | 6    | 6→7→5→4   | -         |
  | 20   | 7    | 7→6→5→4   | -         |

  **LRU结果**:

  - 缺页次数: **10次**
  - 缺页率: 10/20 = **50%**
  - 命中率: 50%

  ------

  **(2) EAT计算 (FIFO)**:

  ```
  m = 100ns
  p = 0.6 (60%)
  s = 10ms = 10,000,000ns
  
  EAT = m + p × s
      = 100 + 0.6 × 10,000,000
      = 100 + 6,000,000
      = 6,000,100ns
      ≈ 6ms
  ```

  **(3) 性能对比**:

  - **FIFO**: 缺页率60%，性能较差
  - **LRU**: 缺页率50%，性能较好
  - **性能提升**: (60% - 50%) / 60% = 16.7%
  - **结论**: LRU利用了程序的局部性原理，性能明显优于FIFO

  ------

  ### 综合计算题2: 地址映射与置换算法综合 ⭐⭐⭐

  **题目**:

  某请求分页系统，页面大小为1KB，为某进程分配了**3个物理块**，其页表如下:

  | 页号 | 块号 | 状态位 | 访问位 | 修改位 |
  | ---- | ---- | ------ | ------ | ------ |
  | 0    | 5    | 1      | 1      | 0      |
  | 1    | 8    | 1      | 0      | 1      |
  | 2    | -    | 0      | 0      | 0      |
  | 3    | 2    | 1      | 1      | 1      |
  | 4    | -    | 0      | 0      | 0      |

  现在进程依次访问以下逻辑地址(十进制):

  ```
  2100, 3500, 1024, 4200, 2500
  ```

  要求:

  (1) 计算每个逻辑地址对应的**页号**和**页内偏移**。

  (2) 判断是否发生缺页，如发生缺页，采用**LRU算法**选择淘汰页面，并说明是否需要写回磁盘。

  (3) 计算整个访问过程的**缺页次数**和**缺页率**。

  (4) 如果访存时间100ns，缺页处理时间(不含写回)10ms，写回磁盘时间5ms，计算**有效访问时间**。

  ------

  **答案**:

  **(1) 地址计算**:

  页面大小 = 1KB = 1024B

  **LA = 2100**:

  ```
  p = 2100 / 1024 = 2
  d = 2100 % 1024 = 52
  ```

  **LA = 3500**:

  ```
  p = 3500 / 1024 = 3
  d = 3500 % 1024 = 428
  ```

  **LA = 1024**:

  ```
  p = 1024 / 1024 = 1
  d = 1024 % 1024 = 0
  ```

  **LA = 4200**:

  ```
  p = 4200 / 1024 = 4
  d = 4200 % 1024 = 24
  ```

  **LA = 2500**:

  ```
  p = 2500 / 1024 = 2
  d = 2500 % 1024 = 428
  ```

  ------

  **(2) 缺页处理过程**:

  **初始状态**: 页0, 1, 3在内存 (栈: 0→1→3，从最近到最久)

  **访问1: LA=2100 → 页2**

  - 页2不在内存 → **缺页**
  - LRU: 淘汰页3 (栈底)
  - 页3修改位=1 → **需要写回磁盘**
  - 调入页2
  - 栈: 2→0→1

  **访问2: LA=3500 → 页3**

  - 页3不在内存 → **缺页**
  - LRU: 淘汰页1 (栈底)
  - 页1修改位=1 → **需要写回磁盘**
  - 调入页3
  - 栈: 3→2→0

  **访问3: LA=1024 → 页1**

  - 页1不在内存 → **缺页**
  - LRU: 淘汰页0 (栈底)
  - 页0修改位=0 → **无需写回**
  - 调入页1
  - 栈: 1→3→2

  **访问4: LA=4200 → 页4**

  - 页4不在内存 → **缺页**
  - LRU: 淘汰页2 (栈底)
  - 页2刚调入，修改位=0 → **无需写回**
  - 调入页4
  - 栈: 4→1→3

  **访问5: LA=2500 → 页2**

  - 页2不在内存 → **缺页**
  - LRU: 淘汰页3 (栈底)
  - 页3修改位=1 → **需要写回磁盘**
  - 调入页2
  - 栈: 2→4→1

  ------

  **(3) 统计结果**:

  - **缺页次数**: 5次
  - **总访问次数**: 5次
  - **缺页率**: 5/5 = **100%** (全部缺页)
  - **需要写回次数**: 3次 (页3, 页1, 页3)

  ------

  **(4) EAT计算**:

  ```
  m = 100ns
  s = 10ms = 10,000,000ns (不含写回)
  w = 5ms = 5,000,000ns (写回)
  p = 1.0 (100%缺页)
  q = 3/5 = 0.6 (60%需要写回)
  
  EAT = m + p × [q × (s+w) + (1-q) × s]
      = 100 + 1.0 × [0.6 × 15,000,000 + 0.4 × 10,000,000]
      = 100 + 9,000,000 + 4,000,000
      = 13,000,100ns
      ≈ 13ms
  ```

  **性能下降**: (13,000,100 - 100) / 100 ≈ **130,000倍**

  **结论**:

  - 物理块数太少(3个)导致缺页率极高
  - 频繁写回磁盘进一步恶化性能
  - 实际系统应增加物理块数以降低缺页率

  ------

  ## 六、复习要点总结

  ### 1. 必考知识点

  **① 地址映射** ⭐⭐⭐:

  - 分页: LA → (p, d) → PA = b × pagesize + d
  - 分段: LA = (s, d) → PA = 段始址 + d
  - 段页式: LA = (s, p, d) → 查段表 → 查页表 → PA

  **② 置换算法** ⭐⭐⭐:

  - OPT、FIFO、LRU的原理和计算
  - 缺页率、命中率计算
  - Belady异常

  **③ EAT计算** ⭐⭐:

  - 基本公式: EAT = m + p × s
  - 考虑快表: EAT = a + m + (1-h) × m
  - 考虑修改位: EAT = m + p × (s + q×w)

  **④ 习题对应**:

  - 地址映射: 习题21, 22
  - 分配算法: 习题8, 13, 15
  - 访存次数: 习题20, 28, 30
  > 习题22 原题：在请求分页系统中，某用户程序的逻辑地址空间为16页，每页1KB，分配的内存空间为8KB。某时刻页表如题面所示（“页号/块号”紧凑写成：0317243141259661720），求逻辑地址184BH与5000（十进制）对应的物理地址。  
  > 说明：题库原文未给出答案，解题需依据给定页表按`p = LA / 1KB`、`d = LA % 1KB`方法求页框号并换算物理地址。  
  > 习题15 原题：某动态分区分配系统刚把始址为230K的一块内存分配出去后，空闲分区情况如题面所示（序号/大小/始址：1-80K@50K，2-75K@250K，3-55K@450K，4-90K@550K）。若有作业申请50KB且系统把第2个空闲区分配给该作业，问采用的是________适应算法。  
  > 选项：A. 首次 B. 最佳 C. 循环首次 D. 最坏  
  > 答案：C

  ### 2. 重点对比

  | 项目 | 固定分区 | 可变分区 | 分页     | 分段   | 段页式   |
  | ---- | -------- | -------- | -------- | ------ | -------- |
  | 碎片 | 内碎片   | 外碎片   | 页内碎片 | 外碎片 | 页内碎片 |
  | 分配 | 简单     | 复杂     | 简单     | 复杂   | 简单     |
  | 共享 | 难       | 难       | 难       | 易     | 易       |
  | 访存 | 1次      | 1次      | 2次      | 2次    | 3次      |
  | 地址 | 一维     | 一维     | 一维     | 二维   | 二维     |

  ### 3. 考试策略

  **选择题**: 重点掌握概念、特点、习题对应答案

  **大题**:

  - 地址映射: 熟练计算公式
  - 置换算法: 画表格，标记清楚
  - EAT: 记住公式，注意单位转换(ns, ms)

  **时间分配**: 大题40分，建议30-35分钟

  ------
